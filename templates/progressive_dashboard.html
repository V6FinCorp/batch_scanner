<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progressive Trading Scanner Dashboard</title>
    <link rel="stylesheet" href="simple-theme.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <style>
    /* Table styles (use theme variables so dark/light mode applies) */
    table.symbols-table { width: 100%; border-collapse: collapse; }
    table.symbols-table th, table.symbols-table td { padding: 0.5rem 0.6rem; border-bottom: 1px solid var(--border-color); text-align: right; color: var(--text-primary); }
    table.symbols-table th { text-align: left; user-select: none; cursor: pointer; color: var(--text-secondary); }
    table.symbols-table tr:hover { background: var(--hover-color); }
    table.symbols-table td.symbol-col, table.symbols-table th.symbol-col { text-align: left; position: sticky; left: 0; background: var(--bg-primary); }
    .cell-muted { color: var(--text-muted); }
    .btn-icon { background: var(--bg-accent); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.25rem 0.4rem; margin: 0 0.15rem; cursor: pointer; }
    .btn-icon:hover { background: var(--bg-secondary); }
    .status-badge { display: inline-block; min-width: 60px; padding: 0.1rem 0.4rem; border-radius: 10px; font-size: 0.7rem; text-align: center; }
    .status-idle { background: var(--bg-secondary); color: var(--text-muted); border: 1px solid var(--border-color); }
    .status-running { background: var(--warning); color: #3b2b00; border: 1px solid rgba(0,0,0,0.08); }
    .status-success { background: var(--success); color: #063; border: 1px solid rgba(0,0,0,0.06); }
    .status-error { background: var(--danger); color: #fff; border: 1px solid rgba(0,0,0,0.06); }
    .execution-time { font-size: 0.7rem; margin-left: 0.25rem; opacity: 0.8; }
    .toolbar { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    .search-input { background: var(--bg-accent); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.4rem 0.6rem; min-width: 200px; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .controls-section {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .batch-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .loading-spinner {
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
        }
        
        .modal-content {
            background-color: var(--bg-primary);
            margin: 5% auto;
            padding: 2rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .log-viewer {
            max-height: 400px;
            overflow-y: auto;
            background: var(--bg-accent);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            white-space: pre-wrap;
            color: var(--text-primary);
        }
        
        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.25rem;
            border-radius: 2px;
        }
        
        .log-entry.error {
            background: rgba(239, 68, 68, 0.08);
            border-left: 3px solid var(--danger);
        }
        
        .log-entry.warning {
            background: rgba(251, 191, 36, 0.08);
            border-left: 3px solid var(--warning);
        }
        
        .log-entry.info {
            color: var(--text-secondary);
        }
        
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
        }
        
        .btn-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .btn-close:hover {
            color: var(--text-primary);
        }

        /* Use theme variables for the small inline theme toggle so UI updates */
        .theme-toggle { background: var(--bg-accent); color: var(--text-primary); border:1px solid var(--border-color); border-radius: 4px; padding: 0.35rem 0.5rem; cursor:pointer; }
        .reco-bull { color: var(--success); font-weight:600; }
        .reco-bear { color: var(--danger); font-weight:600; }
        .reco-neutral { color: var(--text-muted); }
        .percent-pos { color: var(--success); }
        .percent-neg { color: var(--danger); }
    .percent-neutral { color: var(--text-muted); }
    .rsi-pos { color: var(--success); font-weight:600; }
    .rsi-neg { color: var(--danger); font-weight:600; }
    .rsi-neutral { color: var(--text-muted); }
        .action-chip { display:inline-block; min-width:26px; padding:0.15rem 0.4rem; margin:0 0.1rem; border-radius:4px; text-align:center; cursor:pointer; background:var(--bg-accent); color:var(--text-primary); border:1px solid var(--border-color); font-size:0.85rem; }
        .chip-running { animation: blink 1s linear infinite; }
        @keyframes blink { 0%{opacity:1}50%{opacity:0.2}100%{opacity:1} }
    </style>
</head>
<body>
    <!-- Header (split: top = title + timestamp, bottom = filters/actions) -->
    <header class="header">
        <div class="header-inner">
        <!-- Top row: title + timestamp + accordion toggle -->
        <div class="header-top">
            <div class="header-top-left">
                <h1 class="header-title"><i class="fas fa-chart-line"></i> Progressive Trading Scanner</h1>
            </div>
            <div class="header-top-right">
                <div class="last-refresh" id="pageLoadTime">Last Refresh: --</div>
                <button id="viewLogsBtnTop" class="icon-btn" title="View Logs"><i class="fas fa-file-alt"></i></button>
                <button id="darkModeToggleTop" class="theme-toggle" title="Toggle Theme"><i class="fas fa-moon"></i></button>
                <button id="filtersToggleBtn" class="accordion-toggle" aria-expanded="true" title="Toggle filters"><i class="fas fa-filter"></i></button>
            </div>
        </div>

        <!-- Bottom row: existing header content (filters, actions). This is collapsible. -->
        <div class="header-bottom" id="headerBottom">
            <div class="header-content">
                <div class="controls-section">
                    <div class="batch-controls toolbar">
                        <button id="runAllBtn" class="btn btn-primary">
                            <i class="fas fa-rocket"></i> Run All Scanners
                        </button>
                        <button id="stopAllBtn" class="btn btn-secondary" disabled>
                            <i class="fas fa-stop"></i> Stop All
                        </button>
                        <span style="opacity:0.6">|</span>
                        <button id="runRSIAllBtn" class="btn btn-secondary" title="Run/Stop RSI for all symbols">
                            <i class="fas fa-wave-square"></i> Run RSI All
                        </button>
                        <button id="runEMAAllBtn" class="btn btn-secondary" title="Run/Stop EMA for all symbols">
                            <i class="fas fa-chart-line"></i> Run EMA All
                        </button>
                        <button id="runDMAAllBtn" class="btn btn-secondary" title="Run/Stop DMA for all symbols">
                            <i class="fas fa-chart-bar"></i> Run DMA All
                        </button>
                        <button id="refreshSymbolsBtn" class="btn btn-secondary">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                    <div class="timeframe-selector">
                        <label>TimeFrame:</label>
                        <select id="timeframeSelect" class="form-select">
                                <option value="5mins">5 mins</option>
                            <option value="15mins" selected>15 mins</option>
                            <option value="30mins">30 mins</option>
                            <option value="1hour">1 hour</option>
                            <option value="daily">Daily</option>
                        </select>
                    </div>
                    <!-- EMA/DMA as % moved to symbols panel header (top-right) -->
                    <div id="filters" style="display:flex; gap:0.5rem; align-items:center;">
                        <label style="margin-right:0.25rem;">Reco:</label>
                        <label><input type="checkbox" id="filter_bull" checked/> Bull</label>
                            <label><input type="checkbox" id="filter_neutral" checked/> Neutral</label>
                        <label><input type="checkbox" id="filter_bear" checked/> Bear</label>
                        <label style="margin-left:0.5rem; margin-right:0.25rem;">EMA/DMA % range:</label>
                        <input type="number" id="filter_pct_min" placeholder="-5" style="width:70px" />
                        <input type="number" id="filter_pct_max" placeholder="5" style="width:70px" />
                        <label><input type="checkbox" id="filter_apply_ema" checked/> EMA</label>
                        <label><input type="checkbox" id="filter_apply_dma" checked/> DMA</label>
                        <button id="applyFiltersBtn" class="btn btn-secondary">Apply</button>
                    </div>
                    <!-- Moved viewLogsBtn & darkModeToggle to header-top for compact layout -->
                </div>
            </div>
        </div>
    </header>

        <!-- Loading State -->
        <div id="loadingState" class="panel" style="text-align: center; padding: 2rem;">
            <div class="loading-spinner"></div>
            <span style="margin-left: 1rem;">Loading symbols...</span>
        </div>

        <!-- Symbols Table -->
        <div id="symbolsContainer" class="panel" style="display: none;margin:1rem">
            <div class="panel-header">
                <h2 class="panel-title">
                    <i class="fas fa-table"></i> Symbols Dashboard
                </h2>
                <div class="panel-actions">
                    <span id="symbolStats">0 symbols loaded</span>
                    <span id="progressInfo" style="margin-left: 1rem;"></span>
                    <span style="margin-left:1rem; display:flex; align-items:center; gap:0.4rem;">
                        <label for="togglePct" style="margin:0; font-size:0.9rem; color:var(--text-secondary);">EMA/DMA as %</label>
                        <input type="checkbox" id="togglePct" />
                    </span>
                </div>
            </div>
            
            <div class="panel-content">
                <div class="toolbar" style="margin-bottom:0.5rem;">
                    <!-- Search removed as requested -->
                    <!-- EMA/DMA as % moved to symbols panel header (top-right) -->
                </div>
                <div class="table-scroll">
                    <table id="symbolsTable" class="symbols-table">
                        <thead id="symbolsTableHead"></thead>
                        <tbody id="symbolsTBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Log Viewer Modal -->
        <div id="logModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-file-alt"></i> Application Logs</h3>
                    <button id="closeLogModal" class="btn-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="controls-section">
                        <button id="clearLogsBtn" class="btn btn-secondary">Clear Logs</button>
                        <button id="refreshLogsBtn" class="btn btn-secondary">Refresh</button>
                        <select id="logLevelFilter" class="form-select">
                            <option value="all">All Levels</option>
                            <option value="error">Errors Only</option>
                            <option value="warning">Warnings+</option>
                            <option value="info">Info+</option>
                        </select>
                    </div>
                    <div id="logViewer" class="log-viewer">Loading logs...</div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div id="statusLeft">Ready</div>
            <div id="statusRight"><span id="currentTime"></span></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
    
    <script>
        // Global state
    let symbols = [];
    let scannerStates = {};
    let runningScans = new Set();
    let totalRunning = 0;
    let stopRequested = false; // stop flag for batch runs
    const stopRequestedFor = { rsi: false, ema: false, dma: false };
    let currentSort = { key: 'Symbol', dir: 'asc' };
    let showPctDiff = JSON.parse(localStorage.getItem('showPctDiff') || 'false');
    let isDarkMode = JSON.parse(localStorage.getItem('darkMode') || 'false');
    let chartInstance = null;
    // Column index map for dynamic header columns
    let colIndexMap = {};
        
        // Toastr configuration
        toastr.options = {
            "closeButton": true,
            "newestOnTop": true,
            "progressBar": true,
            "positionClass": "toast-bottom-right",
            "timeOut": "4000",
            "extendedTimeOut": "1000"
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', async function() {
            updateStatusBar();
            setInterval(updateTime, 1000);
            
            // Build the dynamic table header first so rows render into correct columns
            await buildDynamicHeader();
            await loadSymbols();
            setupEventListeners();
            // init toggles
            const pctEl = document.getElementById('togglePct');
            if (pctEl) {
                pctEl.checked = showPctDiff;
                pctEl.addEventListener('change', () => { showPctDiff = pctEl.checked; localStorage.setItem('showPctDiff', JSON.stringify(showPctDiff)); renderSymbolsTable(); });
            }
            loadDarkModePreference();
            
            // Hide loading state and show symbols
            document.getElementById('loadingState').style.display = 'none';
            document.getElementById('symbolsContainer').style.display = 'flex';
            
            toastr.success('Dashboard loaded successfully!', 'Welcome');

            // Initialize page load timestamp in header-top
            const pageLoadEl = document.getElementById('pageLoadTime');
            if (pageLoadEl) {
                pageLoadEl.textContent = 'Last Refresh: ' + new Date().toLocaleString();
            }

            // Wire the filters accordion toggle (collapses/expands header-bottom)
            const filtersToggleBtn = document.getElementById('filtersToggleBtn');
            const headerBottom = document.getElementById('headerBottom');
            if (filtersToggleBtn && headerBottom) {
                filtersToggleBtn.addEventListener('click', function() {
                    const expanded = this.getAttribute('aria-expanded') === 'true';
                    this.setAttribute('aria-expanded', String(!expanded));
                    headerBottom.classList.toggle('collapsed');

                    // After toggling, recompute group header height for sticky stacking
                    setTimeout(function() {
                        const groupRow = document.querySelector('#symbolsTable thead tr#tableGroupHeader');
                        if (groupRow) {
                            const rect = groupRow.getBoundingClientRect();
                            document.documentElement.style.setProperty('--group-header-height', rect.height + 'px');
                        }
                        // Recompute header offsets for table stickiness
                        computeHeaderOffset();
                    }, 50);
                });
            }

                // Top-row buttons exist but are wired in setupEventListeners() to avoid duplicate handlers
                    const viewLogsBtnTop = document.getElementById('viewLogsBtnTop');
                    const darkModeToggleTop = document.getElementById('darkModeToggleTop');
        });

        // Compute header heights and set CSS variables so table headers stick below the page header
        function computeHeaderOffset() {
            try {
                const headerEl = document.querySelector('header.header');
                const headerInner = document.querySelector('.header-inner');
                let headerHeight = 0;
                if (headerEl) {
                    headerHeight = headerEl.getBoundingClientRect().height;
                } else if (headerInner) {
                    headerHeight = headerInner.getBoundingClientRect().height;
                }
                document.documentElement.style.setProperty('--header-height', headerHeight + 'px');

                // If a group header row exists, set --group-header-height; otherwise zero
                const groupRow = document.querySelector('#symbolsTable thead tr#tableGroupHeader');
                if (groupRow) {
                    const rect = groupRow.getBoundingClientRect();
                    document.documentElement.style.setProperty('--group-header-height', rect.height + 'px');
                } else {
                    document.documentElement.style.setProperty('--group-header-height', '0px');
                }
            } catch (e) { console.warn('computeHeaderOffset failed', e); }
        }

        // Build table header dynamically using configured periods from server
        async function buildDynamicHeader() {
            try {
                // Attempt to fetch config for RSI/EMA/DMA; fall back to sensible defaults
                const rsiRes = await fetch('/api/config/rsi');
                const emaRes = await fetch('/api/config/ema');
                const dmaRes = await fetch('/api/config/dma');
                const rsiCfg = rsiRes.ok ? await rsiRes.json() : {};
                const emaCfg = emaRes.ok ? await emaRes.json() : {};
                const dmaCfg = dmaRes.ok ? await dmaRes.json() : {};

                const rsi_periods = (rsiCfg && rsiCfg.rsi_periods) || [5,15,30];
                const ema_periods = (emaCfg && emaCfg.ema_periods) || [9,15];
                const dma_periods = (dmaCfg && dmaCfg.dma_periods) || [10,20,50,100,200];

                const thead = document.getElementById('symbolsTableHead');
                thead.innerHTML = '';
                const tr = document.createElement('tr');
                // base columns
                const baseCols = [ {k:'Symbol', t:'Symbol', cls:'symbol-col'}, {k:'CMP', t:'CMP'}, {k:'Reco', t:'Reco'} ];
                let idx = 0;
                colIndexMap = {};
                baseCols.forEach(c => { const th = document.createElement('th'); if (c.cls) th.className = c.cls; th.setAttribute('data-key', c.k); th.textContent = c.t; tr.appendChild(th); colIndexMap[c.k] = idx++; });

                // RSI columns
                for (const p of rsi_periods) {
                    const key = `rsi_${p}`;
                    const th = document.createElement('th'); th.setAttribute('data-key', key); th.textContent = `RSI(${p})`; tr.appendChild(th); colIndexMap[key] = idx++;
                }

                // EMA columns
                for (const p of ema_periods) {
                    const key = `ema_${p}`;
                    const th = document.createElement('th'); th.setAttribute('data-key', key); th.textContent = `EMA(${p})`; tr.appendChild(th); colIndexMap[key] = idx++;
                }

                // DMA columns
                for (const p of dma_periods) {
                    const key = `dma_${p}`;
                    const th = document.createElement('th'); th.setAttribute('data-key', key); th.textContent = `DMA(${p})`; tr.appendChild(th); colIndexMap[key] = idx++;
                }

                // Actions
                const thActions = document.createElement('th'); thActions.textContent = 'Actions'; tr.appendChild(thActions); colIndexMap['Actions'] = idx++;

                thead.appendChild(tr);

            } catch (e) {
                console.warn('Failed to build dynamic header, falling back to static header', e);
            }
        }

        // Update offsets on resize and when content/layout changes
        window.addEventListener('resize', function() { computeHeaderOffset(); });
        // Also compute after initial load (in case called earlier)
        window.addEventListener('load', function() { computeHeaderOffset(); });

        // Load symbols from API
        async function loadSymbols() {
            try {
                updateStatusBar('Loading symbols...');
                // Retry with small backoff to survive cold-starts
                const maxAttempts = 3;
                let attempt = 0, response, data, lastErr;
                while (attempt < maxAttempts) {
                    try {
                        response = await fetch('/api/symbol-table', { cache: 'no-store' });
                        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        data = await response.json();
                        break; // success
                    } catch (err) {
                        lastErr = err;
                        attempt++;
                        if (attempt < maxAttempts) {
                            await new Promise(r => setTimeout(r, 400 * attempt));
                        }
                    }
                }
                if (!data) {
                    throw lastErr || new Error('Failed to load symbol table');
                }
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load symbol table');
                }
                
                symbols = data.symbols || [];
                
                // Initialize scanner states
                symbols.forEach(symbol => {
                    const symbolName = symbol.Symbol || symbol;
                    scannerStates[symbolName] = {
                        rsi: { status: 'idle', time: null, data: null },
                        ema: { status: 'idle', time: null, data: null },
                        dma: { status: 'idle', time: null, data: null }
                    };
                });
                
                renderSymbolsTable();
                updateSymbolStats();
                updateStatusBar('Symbols loaded successfully');
                
            } catch (error) {
                console.error('Failed to load symbols:', error);
                toastr.error('Failed to load symbols: ' + error.message, 'Error');
                updateStatusBar('Error loading symbols');
                
                // Show error state
                document.getElementById('loadingState').innerHTML = `
                    <div style="text-align: center; color: #ef4444;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <h3>Failed to load symbols</h3>
                        <p>${error && error.message ? error.message : 'Request failed'}</p>
                        <button onclick="location.reload()" class="btn btn-primary" style="margin-top: 1rem;">
                            <i class="fas fa-refresh"></i> Retry
                        </button>
                    </div>
                `;
            }
        }

        // Render symbols table
        function renderSymbolsTable() {
            const tbody = document.getElementById('symbolsTBody');
            tbody.innerHTML = '';

            const sorted = [...symbols].sort((a, b) => compareByKey(a, b, currentSort.key, currentSort.dir));
            sorted.forEach(row => tbody.appendChild(createTableRow(row)));

            // wire header sorting
            document.querySelectorAll('#symbolsTable thead th[data-key]')
                .forEach(th => {
                    th.onclick = () => {
                        const key = th.getAttribute('data-key');
                        if (currentSort.key === key) {
                            currentSort.dir = currentSort.dir === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort.key = key; currentSort.dir = 'asc';
                        }
                        renderSymbolsTable();
                    }
                });

            // filter
            const search = document.getElementById('tableSearch');
            if (search && !search._wired) {
                search._wired = true;
                search.addEventListener('input', () => applyFilter(search.value || ''));
            }
            // apply advanced filters after rendering
            applyFilters();
        }

        // Compute numeric recommendation score for a symbol (used for sorting)
        function computeRecoScore(symbolData) {
            const safeNum = (v) => {
                if (v === null || v === undefined) return null;
                if (typeof v === 'number') return v;
                const s = String(v).replace(/[^0-9.\-]/g, '');
                const n = parseFloat(s);
                return isNaN(n) ? null : n;
            };

            // symbolData can be either the API object or the symbol name string
            let cmp = null, ema9 = null, ema15 = null, ema65 = null, ema200 = null, rsi15 = null;
            if (typeof symbolData === 'string') {
                // symbol name provided; attempt DOM fallback
                const sym = symbolData;
                const row = document.getElementById(`row-${sym}`);
                if (row) {
                    const cells = row.querySelectorAll('td');
                    // CMP 1, RSI15 3, EMA9 6, EMA15 7, EMA65 8, EMA200 9
                    const cmpCell = cells[1];
                    if (cmpCell) {
                        const attr = cmpCell.getAttribute && cmpCell.getAttribute('data-cmp');
                        cmp = (attr !== null && attr !== undefined) ? parseFloat(attr) : safeNum(cmpCell.innerText);
                    }
                    const readIndicator = (cellIdx) => {
                        const c = cells[cellIdx];
                        if (!c) return null;
                        // If percent-mode rendered, cell may contain data-pct
                        const pctEl = c.querySelector && c.querySelector('[data-pct]');
                        if (pctEl) {
                            const pct = parseFloat(pctEl.getAttribute('data-pct'));
                            if (!isNaN(pct) && cmp) {
                                // reconstruct indicator value from percent: pct = (indicator - cmp)/cmp *100 => indicator = cmp*(1 + pct/100)
                                return cmp * (1 + (pct / 100));
                            }
                        }
                        return safeNum(c.innerText);
                    };
                    rsi15 = readIndicator(3);
                    ema9 = readIndicator(6);
                    ema15 = readIndicator(7);
                    ema65 = readIndicator(8);
                    ema200 = readIndicator(9);
                }
            } else {
                // object from API
                cmp = safeNum(symbolData.CMP || symbolData.cmp || symbolData['CMP']);
                ema9 = safeNum(symbolData.ema_9);
                ema15 = safeNum(symbolData.ema_15);
                ema65 = safeNum(symbolData.ema_65);
                ema200 = safeNum(symbolData.ema_200);
                rsi15 = safeNum(symbolData.rsi_15);

                // If missing numeric fields, try DOM fallback using symbol field
                if ((ema9 === null || ema15 === null || ema65 === null) && (symbolData.Symbol || symbolData.symbol)) {
                    const row = document.getElementById(`row-${symbolData.Symbol || symbolData.symbol}`);
                    if (row) {
                        const cells = row.querySelectorAll('td');
                        const cmpCell = cells[1];
                        if (cmpCell) {
                            const attr = cmpCell.getAttribute && cmpCell.getAttribute('data-cmp');
                            cmp = cmp || ((attr !== null && attr !== undefined) ? parseFloat(attr) : safeNum(cmpCell.innerText));
                        }
                        const readIndicator = (cellIdx) => {
                            const c = cells[cellIdx];
                            if (!c) return null;
                            const pctEl = c.querySelector && c.querySelector('[data-pct]');
                            if (pctEl) {
                                const pct = parseFloat(pctEl.getAttribute('data-pct'));
                                if (!isNaN(pct) && cmp) return cmp * (1 + (pct / 100));
                            }
                            return safeNum(c.innerText);
                        };
                        rsi15 = rsi15 || readIndicator(3);
                        ema9 = ema9 || readIndicator(6);
                        ema15 = ema15 || readIndicator(7);
                        ema65 = ema65 || readIndicator(8);
                        ema200 = ema200 || readIndicator(9);
                    }
                }
            }

            let score = 0;
            if (ema9 !== null && ema15 !== null && ema65 !== null) {
                if (ema9 > ema15 && ema15 > ema65) score += 2;
                if (ema9 < ema15 && ema15 < ema65) score -= 2;
            }
            if (cmp !== null && ema200 !== null) {
                if (cmp > ema200) score += 1.5; else if (cmp < ema200) score -= 1.5;
            }
            if (rsi15 !== null) {
                if (rsi15 >= 70) score += 1;
                else if (rsi15 <= 30) score -= 1;
                else if (rsi15 >= 55) score += 0.5;
                else if (rsi15 <= 45) score -= 0.5;
            }
            return score;
        }

        function createTableRow(symbolData) {
            const tr = document.createElement('tr');
            const s = symbolData.Symbol || symbolData;
            tr.id = `row-${s}`;

            const getCellVal = (key) => symbolData[key] ?? '';
            const td = (html, cls='') => { const c = document.createElement('td'); if (cls) c.className = cls; c.innerHTML = html; return c; };
            const fmtNum = (v) => (v === null || v === undefined || v === '') ? '<span class="cell-muted">-</span>' : Number(v).toFixed(2);
            const colorRsiHtml = (v) => {
                if (v===null || v===undefined || v==='') return '<span class="cell-muted">-</span>';
                const n = Number(v); if (isNaN(n)) return '<span class="cell-muted">-</span>';
                // Per user: Red when >=70, Green when <=30, otherwise Grey
                if (n >= 70) return `<span class="rsi-neg">${n.toFixed(2)}</span>`;
                if (n <= 30) return `<span class="rsi-pos">${n.toFixed(2)}</span>`;
                return `<span class="rsi-neutral">${n.toFixed(2)}</span>`;
            };
            const colorCompareHtml = (val, cmp) => {
                // For EMA/DMA: Green if CMP > indicator, Red if CMP < indicator, Grey if equal or unavailable
                if (val===null || val===undefined || val==='') return '<span class="cell-muted">-</span>';
                const n = Number(val); const c = Number(cmp);
                if (isNaN(n)) return '<span class="cell-muted">-</span>';
                if (isNaN(c)) return `<span class="percent-neutral">${n.toFixed(2)}</span>`;
                if (c > n) return `<span class="percent-pos">${n.toFixed(2)}</span>`; // CMP > indicator -> green
                if (c < n) return `<span class="percent-neg">${n.toFixed(2)}</span>`; // CMP < indicator -> red
                return `<span class="percent-neutral">${n.toFixed(2)}</span>`;
            };
            const pct = (val, cmp) => {
                // val = indicator, cmp = CMP
                if (val==null || val==='' || cmp==null || cmp==='' ) return '<span class="cell-muted">-</span>';
                const n = Number(val), c = Number(cmp);
                if (isNaN(n) || isNaN(c) || c===0) return '<span class="cell-muted">-</span>';
                const d = ((n - c)/c)*100;
                // Color GREEN when CMP > indicator (bullish), RED when CMP < indicator (bearish), GREY when equal
                let cls = 'percent-neutral';
                if (c > n) cls = 'percent-pos';
                else if (c < n) cls = 'percent-neg';
                return `<span class="${cls}" data-pct="${d}">${d.toFixed(2)}%</span>`;
            };
            const reco = () => {
                // Weighted scoring to mimic legacy recommendation
                // Sources: EMA alignment (9>15>21), CMP vs DMA200, RSI(15)
                const safeNum = (v) => { const n = Number(v); return isNaN(n)?null:n; };
                const cmp = safeNum(getCellVal('CMP'));
                const ema9 = safeNum(getCellVal('ema_9'));
                const ema15 = safeNum(getCellVal('ema_15'));
                const ema21 = safeNum(getCellVal('ema_21'));
                const dma200 = safeNum(getCellVal('dma_200'));
                const rsi15 = safeNum(getCellVal('rsi_15'));

                let score = 0;
                // EMA alignment weight
                if (ema9 !== null && ema15 !== null && ema21 !== null) {
                    if (ema9 > ema15 && ema15 > ema21) score += 2; // bullish alignment
                    if (ema9 < ema15 && ema15 < ema21) score -= 2; // bearish alignment
                }
                // CMP vs DMA200
                if (cmp !== null && dma200 !== null) {
                    if (cmp > dma200) score += 1.5; else if (cmp < dma200) score -= 1.5;
                }
                // RSI contribution
                if (rsi15 !== null) {
                    if (rsi15 >= 70) score += 1; // strong momentum
                    else if (rsi15 <= 30) score -= 1; // strong sell pressure
                    else if (rsi15 >= 55) score += 0.5;
                    else if (rsi15 <= 45) score -= 0.5;
                }

                // Final mapping
                if (score >= 2.5) return '<span class="reco-bull">Strong Bull</span>';
                if (score >= 1.0) return '<span class="reco-bull">Bullish</span>';
                if (score <= -2.5) return '<span class="reco-bear">Strong Bear</span>';
                if (score <= -1.0) return '<span class="reco-bear">Bearish</span>';
                return '<span class="reco-neutral">Neutral</span>';
            };

            // Symbol cell: chart icon directly left of symbol name
            tr.appendChild(td(`<button class="btn-icon" title="Open Chart" onclick="openChartModal('${s}')" style="margin-right:8px"><i class="fas fa-chart-line"></i></button><span style="vertical-align:middle"><strong>${s}</strong></span>`, 'symbol-col'));
            // CMP cell: render raw text but store a numeric data-cmp attribute for later comparisons
            const rawCmp = getCellVal('CMP');
            const cmpNum = (rawCmp === null || rawCmp === undefined || rawCmp === '') ? NaN : parseFloat(String(rawCmp).replace(/[^0-9.\-]/g,''));
            const cmpCell = document.createElement('td');
            cmpCell.innerHTML = rawCmp ? rawCmp : '<span class="cell-muted">-</span>';
            if (!isNaN(cmpNum)) cmpCell.setAttribute('data-cmp', String(cmpNum));
            tr.appendChild(cmpCell);
            tr.appendChild(td(reco(), 'reco-cell'));
            // Render RSI columns dynamically if present in colIndexMap
            const rsiKeys = Object.keys(colIndexMap).filter(k => k.startsWith('rsi_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
            rsiKeys.forEach(k => tr.appendChild(td(colorRsiHtml(getCellVal(k)))));
            // Use numeric CMP when available (clean any currency/formatting). Pass numeric CMP into helpers
            const cmpVal = !isNaN(cmpNum) ? cmpNum : NaN;
            // Render EMA columns dynamically
            const emaKeys = Object.keys(colIndexMap).filter(k => k.startsWith('ema_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
            emaKeys.forEach(k => tr.appendChild(td(showPctDiff ? pct(getCellVal(k), cmpVal) : colorCompareHtml(getCellVal(k), cmpVal))));
            // Render DMA columns dynamically
            const dmaKeys = Object.keys(colIndexMap).filter(k => k.startsWith('dma_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
            dmaKeys.forEach(k => tr.appendChild(td(showPctDiff ? pct(getCellVal(k), cmpVal) : colorCompareHtml(getCellVal(k), cmpVal))));
            // LastUpdate column removed to match legacy compact table

            // Actions with per-scanner controls and status badges (reuse chip/time ids)
            const actionsHtml = `
                <span id="chip-${s}-rsi" class="action-chip status-idle" title="RSI" onclick="runScanner('${s}', 'rsi')">R</span>
                <span id="chip-${s}-ema" class="action-chip status-idle" title="EMA" onclick="runScanner('${s}', 'ema')">E</span>
                <span id="chip-${s}-dma" class="action-chip status-idle" title="DMA" onclick="runScanner('${s}', 'dma')">D</span>
                <span id="chip-${s}-all" class="action-chip status-idle" title="Run All" onclick="retryAllScannersForSymbol('${s}')">All</span>
            `;
            tr.appendChild(td(actionsHtml));

            // If the symbolData lacks some newer fields (rsi_5, ema_21, dma_100/dma_200),
            // request per-symbol analysis to populate them. This handles cases where
            // /api/symbol-table doesn't include those keys yet.
            (function(symbolObj, rowId){
                const has = (k) => symbolObj && symbolObj[k] !== undefined && symbolObj[k] !== null && symbolObj[k] !== '';
                // Determine required keys dynamically from colIndexMap
                const requiredRsi = Object.keys(colIndexMap).filter(k=>k.startsWith('rsi_'));
                const requiredEma = Object.keys(colIndexMap).filter(k=>k.startsWith('ema_'));
                const requiredDma = Object.keys(colIndexMap).filter(k=>k.startsWith('dma_'));
                const needsRsi = requiredRsi.some(k => !has(k));
                const needsEma = requiredEma.some(k => !has(k));
                const needsDma = requiredDma.some(k => !has(k));
                if (needsRsi || needsEma || needsDma) {
                    // small stagger to avoid bursting requests on large symbol lists
                    setTimeout(() => {
                        try {
                            if (needsRsi) refreshRow(rowId, 'rsi');
                            if (needsEma) refreshRow(rowId, 'ema');
                            if (needsDma) refreshRow(rowId, 'dma');
                        } catch(e) { /* ignore */ }
                    }, 200);
                }
            })(symbolData, s);

            return tr;
        }

        function compareByKey(a, b, key, dir) {
            // Special-case Reco: compute numeric score for sorting to ensure proper ordering
            if (key === 'Reco') {
                const sa = computeRecoScore(a);
                const sb = computeRecoScore(b);
                const cmpScore = (sa || 0) - (sb || 0);
                return dir === 'asc' ? cmpScore : -cmpScore;
            }
            const av = (a[key] !== undefined ? a[key] : (key==='CMP' ? a.CMP : (key==='Symbol' ? a.Symbol : undefined)));
            const bv = (b[key] !== undefined ? b[key] : (key==='CMP' ? b.CMP : (key==='Symbol' ? b.Symbol : undefined)));
            const toNum = (v) => {
                if (v === null || v === undefined) return NaN;
                if (typeof v === 'number') return v;
                const s = String(v).replace(/[^0-9.\-]/g, '');
                const n = parseFloat(s);
                return isNaN(n) ? NaN : n;
            };
            let cmp = 0;
            if (key === 'Symbol' || (isNaN(toNum(av)) && isNaN(toNum(bv)))) {
                cmp = String(av || '').localeCompare(String(bv || ''));
            } else {
                cmp = (toNum(av) || 0) - (toNum(bv) || 0);
            }
            return dir === 'asc' ? cmp : -cmp;
        }

        function applyFilter(term) {
            term = term.toUpperCase();
            const tbody = document.getElementById('symbolsTBody');
            tbody.querySelectorAll('tr').forEach(tr => {
                const sym = tr.id.replace('row-','');
                tr.style.display = sym.toUpperCase().includes(term) ? '' : 'none';
            });
        }

        // New: apply advanced filters (Reco checkboxes + EMA/DMA percent ranges)
        function applyFilters() {
            const min = parseFloat(document.getElementById('filter_pct_min')?.value || NaN);
            const max = parseFloat(document.getElementById('filter_pct_max')?.value || NaN);
            const useEma = document.getElementById('filter_apply_ema')?.checked ?? true;
            const useDma = document.getElementById('filter_apply_dma')?.checked ?? true;
            const showBull = document.getElementById('filter_bull')?.checked ?? true;
            const showNeutral = document.getElementById('filter_neutral')?.checked ?? true;
            const showBear = document.getElementById('filter_bear')?.checked ?? true;

            const tbody = document.getElementById('symbolsTBody');
            tbody.querySelectorAll('tr').forEach(tr => {
                let visible = true;
                // Reco check
                const recoCell = tr.querySelector('.reco-cell');
                if (recoCell) {
                    const txt = recoCell.innerText || '';
                    if (txt.includes('Strong Bull') || txt.includes('Bullish')) {
                        if (!showBull) visible = false;
                    } else if (txt.includes('Strong Bear') || txt.includes('Bearish')) {
                        if (!showBear) visible = false;
                    } else {
                        if (!showNeutral) visible = false;
                    }
                }

                // EMA/DMA percent range check (only when pct toggle enabled)
                if (visible && (useEma || useDma) && document.getElementById('togglePct')?.checked) {
                    // Collect percent values from EMA/DMA columns (they have data-pct if rendered as pct)
                    const cols = tr.querySelectorAll('td');
                    const colIdxs = { ema:[6,7,8], dma:[9,10,11,12,13] };
                    let inRange = true;
                    const checkCols = [];
                    if (useEma) checkCols.push(...colIdxs.ema);
                    if (useDma) checkCols.push(...colIdxs.dma);
                    for (const idx of checkCols) {
                        const cell = cols[idx];
                        if (!cell) continue;
                        const pctEl = cell.querySelector('[data-pct]');
                        let val = NaN;
                        if (pctEl) {
                            val = parseFloat(pctEl.getAttribute('data-pct'));
                        } else {
                            // attempt to parse text like "-1.23%"
                            const txt = (cell.innerText || '').replace('%','').trim();
                            const n = parseFloat(txt);
                            if (!isNaN(n)) val = n;
                        }
                        if (!isNaN(min) && val < min) { inRange = false; break; }
                        if (!isNaN(max) && val > max) { inRange = false; break; }
                    }
                    if (!inRange) visible = false;
                }

                tr.style.display = visible ? '' : 'none';
            });
        }

        // Update scanner chip status (display time inside chip; running shows blink)
        function updateScannerChip(symbol, scanner, status, time = null, error = null) {
            const chip = document.getElementById(`chip-${symbol}-${scanner}`);
            if (!chip) return;

            // Normalize scanner key for state object (some callers may pass 'all')
            if (!scannerStates[symbol]) scannerStates[symbol] = { rsi:{}, ema:{}, dma:{} };
            if (!scannerStates[symbol][scanner]) scannerStates[symbol][scanner] = { status: 'idle', time: null };

            // Update internal state
            scannerStates[symbol][scanner].status = status;
            scannerStates[symbol][scanner].time = time;

            // Map short label
            const labelMap = { rsi: 'R', ema: 'E', dma: 'D', all: 'All' };
            const baseLabel = labelMap[scanner] || (scanner.toUpperCase ? scanner.toUpperCase() : String(scanner));

            // Build chip content
            if (status === 'running') {
                chip.innerHTML = `${baseLabel} <i class="fas fa-spinner fa-spin" style="margin-left:6px;font-size:0.85em"></i>`;
            } else if (status === 'success' && time !== null) {
                chip.innerHTML = `${baseLabel} <span style="font-size:0.78em; opacity:0.9; margin-left:6px">(${time}s)</span>`;
            } else if (status === 'error') {
                chip.innerHTML = `${baseLabel} <i class="fas fa-exclamation-triangle" style="margin-left:6px;color:#ef4444"></i>`;
            } else {
                chip.textContent = baseLabel;
            }

            // Set classes: keep action-chip base, add running animation and status styling
            const runningClass = status === 'running' ? 'chip-running' : '';
            chip.className = `action-chip ${runningClass} status-${status}`.trim();

            // Tooltip for errors
            if (status === 'error' && error) {
                chip.title = `Error: ${error}`;
            } else {
                chip.title = `${scanner.toUpperCase()} - ${status}`;
            }
        }

        // Run individual scanner
        async function runScanner(symbol, scanner) {
            const scanKey = `${symbol}-${scanner}`;
            
            if (runningScans.has(scanKey)) {
                toastr.warning(`${scanner.toUpperCase()} scanner already running for ${symbol}`, 'Already Running');
                return;
            }
            
            try {
                runningScans.add(scanKey);
                totalRunning++;
                updateScannerChip(symbol, scanner, 'running');
                updateProgress();
                
                toastr.info(`Starting ${scanner.toUpperCase()} analysis for ${symbol}`, 'Scanner Started');
                
                const startTime = Date.now();
                
                const response = await fetch('/api/run-single-scanner', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        scanner: scanner,
                        symbol: symbol,
                        baseTimeframe: document.getElementById('timeframeSelect').value,
                        daysToList: 4
                    })
                });
                
                const result = await response.json();
                const executionTime = ((Date.now() - startTime) / 1000).toFixed(1);
                
                if (!response.ok || result.error) {
                    throw new Error(result.error || 'Scanner execution failed');
                }
                
                if (result.returncode === 0) {
                    updateScannerChip(symbol, scanner, 'success', executionTime);
                    toastr.success(`${scanner.toUpperCase()} completed for ${symbol} in ${executionTime}s`, 'Success');
                    await refreshRow(symbol, scanner);
                } else {
                    throw new Error(result.error || `Scanner returned code ${result.returncode}`);
                }
                
            } catch (error) {
                console.error(`Scanner error for ${symbol}-${scanner}:`, error);
                updateScannerChip(symbol, scanner, 'error', null, error.message);
                toastr.error(`${scanner.toUpperCase()} failed for ${symbol}: ${error.message}`, 'Error');
                
            } finally {
                runningScans.delete(scanKey);
                totalRunning--;
                updateProgress();
            }
        }

        // Run all scanners for a symbol
        async function retryAllScannersForSymbol(symbol) {
            const scanners = ['rsi', 'ema', 'dma'];
            
            toastr.info(`Running all scanners for ${symbol}...`, 'Batch Analysis');
            
            for (const scanner of scanners) {
                await runScanner(symbol, scanner);
                // Small delay between scanners
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        // Run all for a specific scanner type
        async function runAllOfScanner(scanner) {
            const list = symbols.map(s => s.Symbol || s);
            let completed = 0;
            totalRunning = 0;
            updateProgress();
            stopRequestedFor[scanner] = false;
            for (const sym of list) {
                await runScanner(sym, scanner);
                completed++;
                updateStatusBar(`${scanner.toUpperCase()} progress: ${completed}/${list.length}`);
                if (stopRequested || stopRequestedFor[scanner]) break;
                await new Promise(r => setTimeout(r, 150));
            }
            updateStatusBar('Ready');
        }

        // Run all scanners for all symbols
        async function runAllScanners() {
            const runBtn = document.getElementById('runAllBtn');
            const stopBtn = document.getElementById('stopAllBtn');
            stopRequested = false;
            if (runBtn) runBtn.disabled = true;
            if (stopBtn) stopBtn.disabled = false;
            
            toastr.info(`Starting batch analysis for ${symbols.length} symbols...`, 'Batch Analysis');
            
            const scanners = ['rsi', 'ema', 'dma'];
            let completed = 0;
            const total = symbols.length * scanners.length;
            
            try {
                for (const symbol of symbols) {
                    if (stopRequested) break;
                    const symbolName = symbol.Symbol || symbol;
                    for (const scanner of scanners) {
                        if (stopRequested) break;
                        try {
                            await runScanner(symbolName, scanner);
                        } catch (err) {
                            // Keep going to next scan even if one fails
                            console.error(`Batch scan error for ${symbolName}-${scanner}:`, err);
                        }
                        completed++;
                        updateStatusBar(`Progress: ${completed}/${total} (${((completed/total)*100).toFixed(1)}%)`);
                        // Small delay to prevent overwhelming the server
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                }
                if (!stopRequested) {
                    toastr.success('Batch analysis completed!', 'Success');
                } else {
                    toastr.warning('Batch analysis stopped by user', 'Stopped');
                }
            } catch (error) {
                toastr.error('Batch analysis interrupted: ' + (error?.message || error), 'Error');
            } finally {
                if (runBtn) runBtn.disabled = false;
                if (stopBtn) stopBtn.disabled = true;
                updateStatusBar('Batch analysis finished');
            }
        }

        // Stop all running scanners
        function stopAllScanners() {
            stopRequested = true;
            // Existing scans will complete; prevent new ones
            toastr.info('Stopping after current scans finish...', 'Stopping');
        }

        // Setup event listeners
        function setupEventListeners() {
            // Guard each element lookup so missing/renamed nodes don't throw errors
            const elRunAll = document.getElementById('runAllBtn'); if (elRunAll) elRunAll.onclick = runAllScanners;
            const elStopAll = document.getElementById('stopAllBtn'); if (elStopAll) elStopAll.onclick = stopAllScanners;
            const elRefresh = document.getElementById('refreshSymbolsBtn'); if (elRefresh) elRefresh.onclick = () => location.reload();

            // Toggle-run/stop buttons for per-scanner batches
            const elRunRSIAll = document.getElementById('runRSIAllBtn'); if (elRunRSIAll) elRunRSIAll.onclick = async function() { const btn = this; if (!btn._running) { btn._running = true; btn.disabled = true; btn.innerHTML = '<i class="fas fa-stop"></i> Stop RSI'; stopRequestedFor.rsi = false; btn.disabled = false; await runAllOfScanner('rsi'); btn._running = false; btn.innerHTML = '<i class="fas fa-wave-square"></i> Run RSI All'; } else { stopRequestedFor.rsi = true; } };
            const elRunEMAAll = document.getElementById('runEMAAllBtn'); if (elRunEMAAll) elRunEMAAll.onclick = async function() { const btn = this; if (!btn._running) { btn._running = true; btn.disabled = true; btn.innerHTML = '<i class="fas fa-stop"></i> Stop EMA'; stopRequestedFor.ema = false; btn.disabled = false; await runAllOfScanner('ema'); btn._running = false; btn.innerHTML = '<i class="fas fa-chart-line"></i> Run EMA All'; } else { stopRequestedFor.ema = true; } };
            const elRunDMAAll = document.getElementById('runDMAAllBtn'); if (elRunDMAAll) elRunDMAAll.onclick = async function() { const btn = this; if (!btn._running) { btn._running = true; btn.disabled = true; btn.innerHTML = '<i class="fas fa-stop"></i> Stop DMA'; stopRequestedFor.dma = false; btn.disabled = false; await runAllOfScanner('dma'); btn._running = false; btn.innerHTML = '<i class="fas fa-chart-bar"></i> Run DMA All'; } else { stopRequestedFor.dma = true; } };

            // Logs and modals
            const elViewLogs = document.getElementById('viewLogsBtn') || document.getElementById('viewLogsBtnTop'); if (elViewLogs) elViewLogs.onclick = openLogModal;
            const elCloseLogModal = document.getElementById('closeLogModal'); if (elCloseLogModal) elCloseLogModal.onclick = closeLogModal;
            const elClearLogs = document.getElementById('clearLogsBtn'); if (elClearLogs) elClearLogs.onclick = clearLogs;
            const elRefreshLogs = document.getElementById('refreshLogsBtn'); if (elRefreshLogs) elRefreshLogs.onclick = loadLogs;

            // Theme toggle (old id or new top-row id)
            const elDarkToggle = document.getElementById('darkModeToggle') || document.getElementById('darkModeToggleTop');
            if (elDarkToggle) {
                try {
                    // Remove any inline onclick handler
                    elDarkToggle.onclick = null;
                    // Clone the node to strip any previously attached event listeners (addEventListener)
                    const cloned = elDarkToggle.cloneNode(true);
                    elDarkToggle.parentNode.replaceChild(cloned, elDarkToggle);
                    cloned.addEventListener('click', function (e) { e.preventDefault(); toggleDarkMode(); });
                } catch (e) {
                    // Fallback: set onclick if cloning fails
                    elDarkToggle.onclick = toggleDarkMode;
                }
            }
        }

        async function refreshRow(symbol, scanner) {
            try {
                const res = await fetch(`/api/symbol-analysis/${scanner}/${symbol}`);
                const data = await res.json();
                if (!data || data.error || !data.data) return;
                const row = document.getElementById(`row-${symbol}`);
                if (!row) return;
                const d = data.data;
                // Update columns we know (new layout includes rsi_5, ema_21, dma_100, dma_200)
                const map = {
                    'rsi': ['rsi_5','rsi_15','rsi_30'],
                    'ema': ['ema_9','ema_15','ema_21'],
                    'dma': ['dma_10','dma_20','dma_50','dma_100','dma_200']
                };
                const fmt = (v) => (v===null||v===undefined||v==='')?'-':Number(v).toFixed(2);
                const cells = row.querySelectorAll('td');
                // Use dynamic colIndexMap built by header builder
                const colIndex = colIndexMap || {};
                for (const key of map[scanner]) {
                    // accept alternate key names returned by older APIs
                    const alternates = [key];
                    if (key === 'rsi_5') alternates.push('rsi_15','rsi_30');
                    if (key === 'ema_21') alternates.push('ema_65');
                    if (key === 'dma_100') alternates.push('dma_50');
                    if (key === 'dma_200') alternates.push('ema_200','dma_50');
                    // find first available data key in payload
                    let dataKey = alternates.find(k => (k in d && d[k] !== undefined && d[k] !== null));
                    if (!dataKey) dataKey = (key in d) ? key : null;
                    if (dataKey && colIndex && colIndex[key] !== undefined) {
                        if (showPctDiff && (key.startsWith('ema_') || key.startsWith('dma_'))) {
                            // Prefer numeric CMP stored on the cell via data-cmp
                            const cmpAttr = cells[1]?.getAttribute && cells[1].getAttribute('data-cmp');
                            const cmpVal = (cmpAttr !== null && cmpAttr !== undefined) ? parseFloat(cmpAttr) : parseFloat(cells[1]?.innerText?.replace(/[^0-9.\-]/g,'') || 'NaN');
                            if (!isNaN(cmpVal) && cmpVal !== 0) {
                                const n = parseFloat(d[dataKey]);
                                if (!isNaN(n)) {
                                    const delta = ((n - cmpVal)/cmpVal)*100;
                                    // CMP > indicator -> bullish (green). CMP < indicator -> bearish (red). Equal -> neutral
                                    let pctClass = 'percent-neutral';
                                    if (cmpVal > n) pctClass = 'percent-pos';
                                    else if (cmpVal < n) pctClass = 'percent-neg';
                                    cells[colIndex[key]].innerHTML = `<span class="${pctClass}" data-pct="${delta}">${delta.toFixed(2)}%</span>`;
                                } else {
                                    cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                                }
                            } else {
                                cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                            }
                        } else {
                            // If this is an RSI key, colorize via RSI thresholds; otherwise compare to CMP for color
                            if (key.startsWith('rsi_')) {
                                const v = d[dataKey] ?? d[key];
                                cells[colIndex[key]].innerHTML = (function(vv){ if (vv===null||vv===undefined||vv==='') return '<span class="cell-muted">-</span>'; const n=Number(vv); if (isNaN(n)) return '<span class="cell-muted">-</span>'; // Per user: >=70 red, <=30 green, else neutral
                                    if (n >= 70) return `<span class="rsi-neg">${n.toFixed(2)}</span>`;
                                    if (n <= 30) return `<span class="rsi-pos">${n.toFixed(2)}</span>`;
                                    return `<span class="rsi-neutral">${n.toFixed(2)}</span>`; })(v);
                            } else {
                                // EMA/DMA: color relative to CMP (neutral if equal or CMP missing)
                                const cmpAttr = cells[1]?.getAttribute && cells[1].getAttribute('data-cmp');
                                const cmpValLocal = (cmpAttr !== null && cmpAttr !== undefined) ? parseFloat(cmpAttr) : parseFloat(cells[1]?.innerText?.replace(/[^0-9.\-]/g,'') || 'NaN');
                                if (!isNaN(cmpValLocal)) {
                                    const n = parseFloat(d[dataKey] ?? d[key]);
                                    if (!isNaN(n)) {
                                        let cls = 'percent-neutral';
                                        if (cmpValLocal > n) cls = 'percent-pos';
                                        else if (cmpValLocal < n) cls = 'percent-neg';
                                        cells[colIndex[key]].innerHTML = `<span class="${cls}">${n.toFixed(2)}</span>`;
                                    } else {
                                        cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                                    }
                                } else {
                                    cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                                }
                            }
                        }
                    }
                }
                // No LastUpdate column in compact view
                // Update Reco cell (CMP is at col index 1)
                const cmpVal = parseFloat(cells[colIndex['CMP']]?.innerText?.replace(/[^0-9.\-]/g,'') || '');
                const readVal = (cellOrKey, idx) => {
                    // Prefer data from API (d[key]) else from cell text, stripping % if present
                    const k = cellOrKey;
                    if (d && (k in d) && d[k] !== null && d[k] !== undefined) return parseFloat(d[k]);
                    const cellText = cells[idx]?.innerText || '';
                    if (cellText.includes('%')) return parseFloat(cellText.replace('%','')) * 0.01 * cmpVal; // percent -> absolute
                    return parseFloat(cellText.replace(/[^0-9.\-]/g,''));
                };
                const ema9 = readVal('ema_9', colIndex['ema_9']);
                const ema15 = readVal('ema_15', colIndex['ema_15']);
                const ema21 = readVal('ema_21', colIndex['ema_21']);
                const dma200 = readVal('dma_200', colIndex['dma_200']);
                const rsi15 = readVal('rsi_15', colIndex['rsi_15']);
                let recoCell = row.querySelector('.reco-cell');
                if (recoCell) {
                    // Compute weighted score (same as initial render)
                    const safeNum = (v) => { const n = Number(v); return isNaN(n)?null:n; };
                    const cmp_v = safeNum(cmpVal);
                    const e9 = safeNum(ema9), e15 = safeNum(ema15), e21 = safeNum(ema21), d200 = safeNum(dma200), r15 = safeNum(rsi15);
                    let score = 0;
                    if (e9 !== null && e15 !== null && e21 !== null) {
                        if (e9 > e15 && e15 > e21) score += 2;
                        if (e9 < e15 && e15 < e21) score -= 2;
                    }
                    if (cmp_v !== null && d200 !== null) { if (cmp_v > d200) score += 1.5; else if (cmp_v < d200) score -= 1.5; }
                    if (r15 !== null) { if (r15 >= 70) score += 1; else if (r15 <= 30) score -= 1; else if (r15 >= 55) score += 0.5; else if (r15 <= 45) score -= 0.5; }
                    if (score >= 2.5) recoCell.innerHTML = '<span class="reco-bull">Strong Bull</span>';
                    else if (score >= 1.0) recoCell.innerHTML = '<span class="reco-bull">Bullish</span>';
                    else if (score <= -2.5) recoCell.innerHTML = '<span class="reco-bear">Strong Bear</span>';
                    else if (score <= -1.0) recoCell.innerHTML = '<span class="reco-bear">Bearish</span>';
                    else recoCell.innerHTML = '<span class="reco-neutral">Neutral</span>';
                }
            } catch(e) { /* ignore */ }
        }

        // Update symbol statistics
        function updateSymbolStats() {
            const total = symbols.length;
            document.getElementById('symbolStats').textContent = `${total} symbols loaded`;
        }

        // Update progress information
        function updateProgress() {
            const progressEl = document.getElementById('progressInfo');
            if (totalRunning > 0) {
                progressEl.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${totalRunning} scanners running`;
                progressEl.style.color = '#fbbf24';
            } else {
                progressEl.textContent = '';
            }
        }

        // Update status bar
        function updateStatusBar(message = 'Ready') {
            document.getElementById('statusLeft').textContent = message;
        }

        // Update current time
        function updateTime() {
            document.getElementById('currentTime').textContent = new Date().toLocaleTimeString();
        }

        // Log modal functions
        function openLogModal() {
            document.getElementById('logModal').style.display = 'block';
            loadLogs();
        }

        function closeLogModal() {
            document.getElementById('logModal').style.display = 'none';
        }

        async function loadLogs() {
            try {
                const response = await fetch('/api/logs');
                const data = await response.json();
                
                if (data.success) {
                    const logViewer = document.getElementById('logViewer');
                    if (data.logs && data.logs.length > 0) {
                        logViewer.textContent = data.logs.join('');
                        logViewer.scrollTop = logViewer.scrollHeight;
                    } else {
                        logViewer.textContent = 'No logs available';
                    }
                } else {
                    throw new Error(data.error || 'Failed to load logs');
                }
            } catch (error) {
                document.getElementById('logViewer').textContent = 'Error loading logs: ' + error.message;
                toastr.error('Failed to load logs', 'Error');
            }
        }

        async function clearLogs() {
            try {
                const response = await fetch('/api/clear-logs', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('logViewer').textContent = 'Logs cleared';
                    toastr.success('Logs cleared successfully', 'Success');
                } else {
                    throw new Error(data.error || 'Failed to clear logs');
                }
            } catch (error) {
                toastr.error('Failed to clear logs: ' + error.message, 'Error');
            }
        }

        // Click outside modal to close
        window.onclick = function(event) {
            const modal = document.getElementById('logModal');
            if (event.target === modal) {
                closeLogModal();
            }
        }

        // Dark mode
        function updateThemeToggleUI() {
            // Update any toggle icon/text for both old and new IDs
            const btn = document.getElementById('darkModeToggle') || document.getElementById('darkModeToggleTop');
            if (!btn) return;
            // Use sun icon for light mode, moon for dark
            btn.innerHTML = isDarkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            btn.setAttribute('aria-pressed', String(isDarkMode));
            console.debug('[theme] updateThemeToggleUI: isDarkMode=', isDarkMode);
        }

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.body.classList.add('dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
                document.body.classList.remove('dark');
            }
            localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
            console.debug('[theme] toggleDarkMode -> isDarkMode=', isDarkMode);
            updateThemeToggleUI();
        }

        function loadDarkModePreference() {
            // Ensure isDarkMode is boolean from localStorage
            isDarkMode = JSON.parse(localStorage.getItem('darkMode') || JSON.stringify(isDarkMode));
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.body.classList.add('dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
                document.body.classList.remove('dark');
            }
            console.debug('[theme] loadDarkModePreference -> isDarkMode=', isDarkMode);
            updateThemeToggleUI();
        }

        // Chart modal for per-symbol chart
        function openChartModal(symbol) {
            // build simple modal dynamically
            const modalId = 'chartSymbolModal';
            let modal = document.getElementById(modalId);
            if (!modal) {
                modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'modal';
                modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3><i class="fas fa-chart-line"></i> Chart - <span id="chartSymbolName"></span></h3>
                        <button class="btn-close" id="closeChartModal">&times;</button>
                    </div>
                    <div style="display:flex; gap:0.75rem; align-items:center; margin-bottom:0.5rem;">
                        <label style="margin-right:6px">Scanners:</label>
                        <label style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="modalEnableEMA" checked/> EMA</label>
                        <label style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="modalEnableDMA" checked/> DMA</label>
                        <span style="flex:1"></span>
                        <button class="btn btn-secondary" id="reloadChartBtn"><i class="fas fa-sync"></i> Reload</button>
                    </div>
                    <!-- Two stacked canvases: price (top) and RSI (bottom) -->
                    <div style="display:flex; flex-direction:column; gap:0.5rem;">
                        <div style="height:260px;">
                            <canvas id="symbolPriceCanvas"></canvas>
                        </div>
                        <div style="height:160px;">
                            <canvas id="symbolRSICanvas"></canvas>
                        </div>
                    </div>
                </div>`;
                document.body.appendChild(modal);
                document.getElementById('closeChartModal').onclick = () => modal.style.display = 'none';
                window.addEventListener('click', (e) => { if (e.target === modal) modal.style.display='none'; });
            }
            document.getElementById('chartSymbolName').textContent = symbol;
            modal.style.display = 'block';
            const load = async () => {
                const enableEMA = document.getElementById('modalEnableEMA')?.checked ?? true;
                const enableDMA = document.getElementById('modalEnableDMA')?.checked ?? true;
                await loadSymbolChart(symbol, { enableEMA, enableDMA });
            };
            // Wire checkbox toggles
            const emaCb = document.getElementById('modalEnableEMA'); if (emaCb) emaCb.onchange = load;
            const dmaCb = document.getElementById('modalEnableDMA'); if (dmaCb) dmaCb.onchange = load;
            const reload = document.getElementById('reloadChartBtn'); if (reload) reload.onclick = load;
            load();
        }
    async function loadSymbolChart(symbol, options = { enableEMA: true, enableDMA: true }) {
            try {
                    // Fetch chart data for all scanners (rsi, ema, dma) and merge into a single combined chartData
                    const scannersToFetch = ['rsi','ema','dma'];
                    const fetches = await Promise.all(scannersToFetch.map(s =>
                        fetch(`/api/chart-data/${s}/${symbol}`).then(r => r.ok ? r.json() : { error: `HTTP ${r.status}` }).catch(e => ({ error: e.message }))
                    ));

                    // Build combined chartData
                    const combined = { labels: null, datasets: [] };
                    const seenLabels = new Set();
                    for (const resp of fetches) {
                        if (!resp || resp.error || !resp.chartData) continue;
                        const part = resp.chartData;
                        if (!combined.labels && Array.isArray(part.labels)) combined.labels = part.labels.slice();
                        if (Array.isArray(part.datasets)) {
                            for (const ds of part.datasets) {
                                // Avoid duplicate dataset labels
                                const label = (ds && ds.label) ? ds.label : JSON.stringify(ds);
                                if (seenLabels.has(label)) continue;
                                seenLabels.add(label);
                                // Clone dataset to avoid mutations
                                const copy = Object.assign({}, ds);
                                // Ensure data arrays are copied
                                if (Array.isArray(ds.data)) copy.data = ds.data.slice();
                                combined.datasets.push(copy);
                            }
                        }
                    }

                    if (!combined.labels || combined.datasets.length === 0) {
                        toastr.error('No chart data available for this symbol');
                        return;
                    }

                    // Filter combined datasets according to options (enableEMA / enableDMA)
                    const cd = { labels: combined.labels.slice(), datasets: [] };
                    for (const ds of combined.datasets) {
                        const lbl = (ds && ds.label) ? ds.label.toUpperCase() : '';
                        if (/^EMA\(/.test(lbl) && !options.enableEMA) continue;
                        if (/^DMA\(/.test(lbl) && !options.enableDMA) continue;
                        cd.datasets.push(ds);
                    }
                    // Debugging: list merged datasets in console and show a small toast so user can verify
                    try {
                        const labelsList = cd.datasets.map(ds => ds.label || '<no-label>');
                        console.log('[chart] combined labels count=', (cd.labels && cd.labels.length) || 0, 'datasets=', labelsList);
                        if (window.toastr) toastr.info(`Combined chart built: ${labelsList.length} datasets`, 'Chart Debug');
                        // Ensure non-OHLC datasets are set to 'line' so they render when mixed with candlestick
                        for (const ds of cd.datasets) {
                            const lbl = ds && ds.label ? ds.label : '<no-label>';
                            if (!(lbl && lbl.toUpperCase() === 'OHLC')) {
                                if (!ds.type) ds.type = 'line';
                                // Coerce data values to numbers where appropriate (skip OHLC arrays)
                                if (Array.isArray(ds.data) && ds.data.length > 0 && !(typeof ds.data[0] === 'object')) {
                                    ds.data = ds.data.map(v => { const n = Number(v); return isNaN(n) ? null : n; });
                                }
                            }
                        }
                        // Detailed dump: label, type, data length and sample
                        const detailed = cd.datasets.map(ds => ({ label: ds.label || '<no-label>', type: ds.type || '<none>', len: Array.isArray(ds.data) ? ds.data.length : 'na', sample: Array.isArray(ds.data) ? ds.data.slice(0,3) : ds.data }));
                        console.log('[chart] combined detailed datasets ->', detailed);
                    } catch (e) { /* ignore */ }

                    // Destroy previous chart instances if present (use Chart.getChart to be robust)
                    try {
                        const pc = document.getElementById('symbolPriceCanvas');
                        const existingPrice = (window.Chart && pc) ? Chart.getChart(pc) : null;
                        if (existingPrice) { try { existingPrice.destroy(); } catch(e) { console.warn('Failed to destroy existing price chart', e); } }
                    } catch(e) { console.warn('Error while destroying price chart', e); }
                    try {
                        const rc = document.getElementById('symbolRSICanvas');
                        const existingRsi = (window.Chart && rc) ? Chart.getChart(rc) : null;
                        if (existingRsi) { try { existingRsi.destroy(); } catch(e) { console.warn('Failed to destroy existing rsi chart', e); } }
                    } catch(e) { console.warn('Error while destroying rsi chart', e); }

                    const textColor = isDarkMode ? '#f9fafb' : '#374151';
                    const gridColor = isDarkMode ? '#4b5563' : '#e5e7eb';

                    // Combined view: top = price (candlestick + close) + EMA/DMA overlays; bottom = RSI series if present
                    try {
                        const priceCtx = document.getElementById('symbolPriceCanvas').getContext('2d');
                        const rsiCanvasParent = document.getElementById('symbolRSICanvas').parentElement;

                        const allDatasets = cd.datasets || [];
                        const ohlc = allDatasets.find(d => d.label && d.label.toUpperCase() === 'OHLC');

                        // Detect candlestick controller availability
                        const candlestickAvailable = (typeof Chart !== 'undefined' && Chart.registry && !!Chart.registry.getController('candlestick'));

                        const priceDatasets = [];
                        if (ohlc && candlestickAvailable) {
                            const mapped = ohlc.data.map((arr, i) => ({ x: i, o: arr[0], h: arr[1], l: arr[2], c: arr[3] }));
                            priceDatasets.push({ label: 'OHLC', data: mapped, type: 'candlestick' });
                        } else if (ohlc && !candlestickAvailable) {
                            console.warn('Candlestick controller not available; falling back to close-price line');
                        }

                        // Close price dataset detection (fallback to first non-RSI numeric dataset)
                        let closeDs = allDatasets.find(d => d.label && /close/i.test(d.label));
                        if (!closeDs) closeDs = allDatasets.find(d => d.label && !/rsi|ohlc/i.test(d.label) && Array.isArray(d.data));
                        if (closeDs) {
                            priceDatasets.push({ label: closeDs.label || 'Close', data: closeDs.data, type: 'line', borderColor: 'rgb(229,237,243)', backgroundColor: 'rgba(59,130,246,0.08)', fill: false, pointRadius: 0, tension: 0.12 });
                        }

                        // Overlay EMA/DMA indicators if present
                        const indicatorSets = allDatasets.filter(d => d.label && (/EMA/i.test(d.label) || /DMA/i.test(d.label) || /ema_/i.test(d.label) || /dma_/i.test(d.label)));
                        const overlayColors = ['rgb(59,130,246)','rgb(16,185,129)','rgb(249,115,22)','rgb(14,165,233)','rgb(250,204,21)'];
                        indicatorSets.forEach((d, i) => priceDatasets.push({ label: d.label, data: d.data, type: 'line', borderColor: overlayColors[i % overlayColors.length], backgroundColor: 'rgba(0,0,0,0)', fill: false, pointRadius: 0, tension: 0.12 }));

                        // If OHLC candlesticks are present and plugin is used, convert numeric overlay datasets to {x,y}
                        // points so they align with the candlestick objects and are rendered reliably.
                        if (ohlc && candlestickAvailable) {
                            priceDatasets.forEach(ds => {
                                if (ds && ds.type === 'line' && Array.isArray(ds.data) && ds.data.length > 0 && typeof ds.data[0] !== 'object') {
                                    ds.data = ds.data.map((v, i) => ({ x: i, y: (v === null || v === undefined) ? null : Number(v) }));
                                    ds.parsing = false;
                                    ds.order = 1; // draw above candlesticks
                                    ds.borderWidth = ds.borderWidth || 2;
                                    ds.spanGaps = true;
                                }
                            });
                        } else {
                            // Ensure overlays are visible for line-only top chart
                            priceDatasets.forEach(ds => { if (ds && ds.type === 'line') { ds.order = ds.order || 1; ds.borderWidth = ds.borderWidth || 2; ds.spanGaps = true; } });
                        }

                        // Build top chart (candlestick if available; otherwise line). Force category x-axis to avoid date adapter usage.
                        const topType = (ohlc && candlestickAvailable) ? 'candlestick' : 'line';
                        const topChart = new Chart(priceCtx, {
                            type: topType,
                            data: { labels: cd.labels, datasets: priceDatasets },
                            options: {
                                responsive: true, maintainAspectRatio: false,
                                interaction: { mode: 'index', intersect: false },
                                scales: { x: { type: 'category', ticks: { color: textColor }, grid: { color: gridColor } }, y: { ticks: { color: textColor }, grid: { color: gridColor } } },
                                plugins: { legend: { labels: { color: textColor } } }
                            }
                        });
                        document.getElementById('symbolPriceCanvas')._chart = topChart;
                        document.getElementById('symbolPriceCanvas').parentElement.style.display = '';

                        // --- Synchronization helpers (hover, wheel-zoom, drag-pan) ---
                        // We synchronize by using category index indices for the x-axis (labels array indices).
                        const priceCanvas = document.getElementById('symbolPriceCanvas');
                        const rsiCanvas = document.getElementById('symbolRSICanvas');

                        // Helper: set visible window (min/max index) for both charts
                        function syncSetWindow(minIdx, maxIdx, sourceChart) {
                            // clamp
                            const maxLabelIndex = Math.max(0, cd.labels.length - 1);
                            minIdx = Math.max(0, Math.min(minIdx, maxLabelIndex));
                            maxIdx = Math.max(0, Math.min(maxIdx, maxLabelIndex));
                            if (minIdx >= maxIdx) {
                                // Ensure at least one label visible
                                if (minIdx > 0) minIdx = minIdx - 1;
                                else maxIdx = Math.min(minIdx + 1, maxLabelIndex);
                            }
                            [topChart, rsiChart].forEach(ch => {
                                if (!ch) return;
                                try {
                                    ch.options.scales.x.min = minIdx;
                                    ch.options.scales.x.max = maxIdx;
                                    // update without animation for snappy sync
                                    ch.update('none');
                                } catch (e) { /* ignore */ }
                            });
                        }

                        // Helper: get x-index under event for a chart using its x scale
                        function getIndexForEvent(chart, evt) {
                            try {
                                const xScale = chart.scales.x;
                                if (!xScale) return null;
                                // event offsetX relative to canvas
                                const rect = chart.canvas.getBoundingClientRect();
                                const clientX = evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX);
                                const px = clientX - rect.left;
                                const value = xScale.getValueForPixel(px);
                                if (value === undefined || value === null) return null;
                                // value may be fractional - round to nearest label index
                                return Math.round(Number(value));
                            } catch (e) { return null; }
                        }

                        // Hover synchronization: when hovering one chart, highlight corresponding index on the other
                        function syncHover(sourceChart, targetChart, evt) {
                            if (!sourceChart || !targetChart) return;
                            const idx = getIndexForEvent(sourceChart, evt);
                            if (idx === null || isNaN(idx)) {
                                // clear
                                try { targetChart.setActiveElements([]); targetChart.update('none'); } catch(e){}
                                return;
                            }
                            // Build active elements for targetChart: include every dataset that has a value at this index
                            const active = [];
                            for (let di = 0; di < targetChart.data.datasets.length; di++) {
                                const ds = targetChart.data.datasets[di];
                                if (!ds || !Array.isArray(ds.data)) continue;
                                // For OHLC/candlestick the ds.data may contain objects, we only check existence
                                if (idx >= 0 && idx < ds.data.length) {
                                    const val = ds.data[idx];
                                    if (val !== null && val !== undefined) active.push({ datasetIndex: di, index: idx });
                                }
                            }
                            try {
                                targetChart.setActiveElements(active);
                                // Also update tooltip to show on the target chart
                                const elPos = { x: sourceChart.canvas.getBoundingClientRect().left + (sourceChart.width || sourceChart.canvas.width) * 0.5, y: sourceChart.canvas.getBoundingClientRect().top };
                                targetChart.tooltip.setActiveElements(active, { x: elPos.x, y: elPos.y });
                                targetChart.update('none');
                            } catch (e) {
                                // ignore errors from tooltip API if not available
                            }
                        }

                        // Attach hover events (mouse move and leave) on both canvases
                        priceCanvas.addEventListener('mousemove', function(evt) { try { syncHover(topChart, rsiChart, evt); } catch(e){} });
                        rsiCanvas.addEventListener('mousemove', function(evt) { try { syncHover(rsiChart, topChart, evt); } catch(e){} });
                        priceCanvas.addEventListener('mouseleave', function() { try { rsiChart.setActiveElements([]); rsiChart.tooltip.setActiveElements([]); rsiChart.update('none'); topChart.setActiveElements([]); topChart.tooltip.setActiveElements([]); topChart.update('none'); } catch(e){} });
                        rsiCanvas.addEventListener('mouseleave', function() { try { rsiChart.setActiveElements([]); rsiChart.tooltip.setActiveElements([]); rsiChart.update('none'); topChart.setActiveElements([]); topChart.tooltip.setActiveElements([]); topChart.update('none'); } catch(e){} });

                        // Wheel zoom: zoom centered at pointer for price canvas (and mirror to RSI)
                        (function attachWheelZoom(canvas, sourceChart) {
                            let zoomFactor = 0.15; // fraction to zoom per wheel step
                            canvas.addEventListener('wheel', function(evt) {
                                try {
                                    evt.preventDefault();
                                    const delta = Math.sign(evt.deltaY);
                                    const xScale = sourceChart.scales.x;
                                    if (!xScale) return;
                                    const curMin = (xScale.min !== undefined && xScale.min !== null) ? Number(xScale.min) : 0;
                                    const curMax = (xScale.max !== undefined && xScale.max !== null) ? Number(xScale.max) : (cd.labels.length - 1);
                                    const curRange = curMax - curMin;
                                    const centerVal = xScale.getValueForPixel(evt.offsetX);
                                    const center = (centerVal === undefined || centerVal === null) ? Math.round((curMin + curMax)/2) : Number(centerVal);
                                    // delta > 0 => zoom out, delta < 0 => zoom in
                                    const scaleDelta = (delta > 0) ? (1 + zoomFactor) : (1 - zoomFactor);
                                    let newRange = curRange * scaleDelta;
                                    // Enforce min window of 2 and max window of all labels
                                    newRange = Math.max(2, Math.min(newRange, cd.labels.length - 1));
                                    let newMin = center - newRange/2;
                                    let newMax = center + newRange/2;
                                    // clamp
                                    newMin = Math.max(0, newMin);
                                    newMax = Math.min(cd.labels.length - 1, newMax);
                                    syncSetWindow(Math.round(newMin), Math.round(newMax), sourceChart);
                                } catch (e) { console.warn('wheel zoom error', e); }
                            }, { passive: false });
                        })(priceCanvas, topChart);

                        // Drag-to-pan (mouse) on price canvas: basic implementation
                        (function attachDragPan(canvas, sourceChart) {
                            let dragging = false, startX = 0, startMin = null, startMax = null;
                            canvas.addEventListener('mousedown', function(evt) {
                                dragging = true; startX = evt.clientX; const xScale = sourceChart.scales.x; startMin = Number(xScale.min || 0); startMax = Number(xScale.max || (cd.labels.length - 1)); canvas.style.cursor = 'grabbing';
                            });
                            window.addEventListener('mouseup', function() { if (dragging) { dragging = false; canvas.style.cursor = 'default'; } });
                            window.addEventListener('mousemove', function(evt) {
                                if (!dragging) return;
                                try {
                                    const xScale = sourceChart.scales.x;
                                    const pxDelta = evt.clientX - startX;
                                    // Map pixel delta to index delta using scale
                                    const valueAtStart = xScale.getValueForPixel(startX - canvas.getBoundingClientRect().left);
                                    const valueAtShift = xScale.getValueForPixel((startX - canvas.getBoundingClientRect().left) + pxDelta);
                                    if (valueAtStart === undefined || valueAtShift === undefined) return;
                                    const idxDelta = Math.round(valueAtStart - valueAtShift);
                                    let newMin = Math.round(startMin + idxDelta);
                                    let newMax = Math.round(startMax + idxDelta);
                                    // clamp
                                    const maxLabelIndex = Math.max(0, cd.labels.length - 1);
                                    if (newMin < 0) { newMax += -newMin; newMin = 0; }
                                    if (newMax > maxLabelIndex) { newMin -= (newMax - maxLabelIndex); newMax = maxLabelIndex; }
                                    syncSetWindow(newMin, newMax, sourceChart);
                                } catch (e) { /* ignore */ }
                            });
                        })(priceCanvas, topChart);

                        // Decide on RSI panel visibility (rendered below independently)
                        const rsiSets = allDatasets.filter(ds => ds.label && /RSI/i.test(ds.label));
                        if (!rsiSets || rsiSets.length === 0) {
                            rsiCanvasParent.style.display = 'none';
                        } else {
                            rsiCanvasParent.style.display = '';
                        }
                    } catch (err) {
                        console.error('Combined price/indicator chart render failed', err);
                    }

                    // RSI CHART (bottom): render RSI series between 0-100 with threshold lines
                    try {
                        // Determine RSI thresholds from server config
                        let rsiCfg = {};
                        try {
                            const cfgRes = await fetch('/api/config/rsi');
                            if (cfgRes.ok) rsiCfg = await cfgRes.json();
                        } catch (e) { /* ignore */ }
                        const overbought = (rsiCfg && rsiCfg.rsi_overbought) ? rsiCfg.rsi_overbought : 70;
                        const oversold = (rsiCfg && rsiCfg.rsi_oversold) ? rsiCfg.rsi_oversold : 30;

                        const rsiCtx = document.getElementById('symbolRSICanvas').getContext('2d');
                        // Find RSI datasets (labels contain 'RSI')
                        const rsiSets = cd.datasets.filter(ds => ds.label && ds.label.toUpperCase().includes('RSI'));
                        const rsiDatasets = rsiSets.map((ds, i) => ({ label: ds.label, data: ds.data, borderColor: ['rgb(34,197,94)','rgb(168,85,247)','rgb(251,146,60)'][i%3], backgroundColor: 'rgba(0,0,0,0)', fill: false, pointRadius: 0, tension: 0.1 }));

                        // Add horizontal plugins for threshold lines using annotation plugin if available; otherwise draw with dataset lines
                        const plugins = [];
                        let annotationOptions = {};
                        if (window.Chart && Chart.register && Chart._adapters && Chart.register.__annotations_supported !== false) {
                            // We'll try to use the annotation plugin if present
                        }

                        // Fallback: add two thin datasets representing thresholds so lines appear
                        const thresholdDatasets = [
                            { label: 'Overbought', data: Array(cd.labels.length).fill(overbought), borderColor: 'rgba(239,68,68,0.6)', borderDash: [6,4], pointRadius: 0, fill: false, order: 0 },
                            { label: 'Oversold', data: Array(cd.labels.length).fill(oversold), borderColor: 'rgba(34,197,94,0.6)', borderDash: [6,4], pointRadius: 0, fill: false, order: 0 }
                        ];

                        const rsiChart = new Chart(rsiCtx, {
                            type: 'line',
                            data: { labels: cd.labels, datasets: [...rsiDatasets, ...thresholdDatasets] },
                            options: {
                                responsive: true, maintainAspectRatio: false,
                                scales: {
                                    x: { ticks: { color: textColor }, grid: { color: gridColor } },
                                    y: { min: 0, max: 100, ticks: { color: textColor }, grid: { color: gridColor } }
                                },
                                plugins: { legend: { labels: { color: textColor } } }
                            },
                            plugins
                        });
                        document.getElementById('symbolRSICanvas')._chart = rsiChart;
                    } catch (err) {
                        console.error('RSI chart render failed', err);
                    }
            } catch (e) { toastr.error('Failed to load chart'); }
        }
    </script>
</body>
</html>
