<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Scanner Dashboard</title>
    <link rel="stylesheet" href="simple-theme.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <style>
    /* Table styles (use theme variables so dark/light mode applies) */
    table.symbols-table { width: 100%; border-collapse: collapse; }
    table.symbols-table th, table.symbols-table td { padding: 0.5rem 0.6rem; border-bottom: 1px solid var(--border-color); text-align: right; color: var(--text-primary); }
    table.symbols-table th { text-align: left; user-select: none; cursor: pointer; color: var(--text-secondary); }
    table.symbols-table tr:hover { background: var(--hover-color); }
    table.symbols-table td.symbol-col, table.symbols-table th.symbol-col { text-align: left; position: sticky; left: 0; background: var(--bg-primary); }
    .cell-muted { color: var(--text-muted); }
    .btn-icon { background: var(--bg-accent); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.25rem 0.4rem; margin: 0 0.15rem; cursor: pointer; }
    .btn-icon:hover { background: var(--bg-secondary); }
    .status-badge { display: inline-block; min-width: 60px; padding: 0.1rem 0.4rem; border-radius: 10px; font-size: 0.7rem; text-align: center; }
    .status-idle { background: var(--bg-secondary); color: var(--text-muted); border: 1px solid var(--border-color); }
    .status-running { background: var(--warning); color: #3b2b00; border: 1px solid rgba(0,0,0,0.08); }
    .status-success { background: var(--success); color: #063; border: 1px solid rgba(0,0,0,0.06); }
    .status-error { background: var(--danger); color: #fff; border: 1px solid rgba(0,0,0,0.06); }
    .execution-time { font-size: 0.7rem; margin-left: 0.25rem; opacity: 0.8; }
    .toolbar { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    .search-input { background: var(--bg-accent); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.4rem 0.6rem; min-width: 200px; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .controls-section {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .batch-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .loading-spinner {
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
        }
        
        .modal-content {
            background-color: var(--bg-primary);
            margin: 5% auto;
            padding: 2rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .log-viewer {
            max-height: 400px;
            overflow-y: auto;
            background: var(--bg-accent);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            white-space: pre-wrap;
            color: var(--text-primary);
        }
        
        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.25rem;
            border-radius: 2px;
        }
        
        .log-entry.error {
            background: rgba(239, 68, 68, 0.08);
            border-left: 3px solid var(--danger);
        }
        
        .log-entry.warning {
            background: rgba(251, 191, 36, 0.08);
            border-left: 3px solid var(--warning);
        }
        
        .log-entry.info {
            color: var(--text-secondary);
        }
        
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
        }
        
        .btn-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .btn-close:hover {
            color: var(--text-primary);
        }

        /* Use theme variables for the small inline theme toggle so UI updates */
        .theme-toggle { background: var(--bg-accent); color: var(--text-primary); border:1px solid var(--border-color); border-radius: 4px; padding: 0.35rem 0.5rem; cursor:pointer; }
        .reco-bull { color: var(--success); font-weight:600; }
        .reco-bear { color: var(--danger); font-weight:600; }
        .reco-neutral { color: var(--text-muted); }
        .percent-pos { color: var(--success); }
        .percent-neg { color: var(--danger); }
    .percent-neutral { color: var(--text-muted); }
    .rsi-pos { color: var(--success); font-weight:600; }
    .rsi-neg { color: var(--danger); font-weight:600; }
    .rsi-neutral { color: var(--text-muted); }
        .action-chip { display:inline-block; min-width:26px; padding:0.15rem 0.4rem; margin:0 0.1rem; border-radius:4px; text-align:center; cursor:pointer; background:var(--bg-accent); color:var(--text-primary); border:1px solid var(--border-color); font-size:0.85rem; }
        .chip-running { animation: blink 1s linear infinite; }
        @keyframes blink { 0%{opacity:1}50%{opacity:0.2}100%{opacity:1} }
    .action-popup { position:absolute; z-index:2000; background:var(--bg-primary); border:1px solid var(--border-color); padding:6px; border-radius:6px; box-shadow:0 6px 18px rgba(0,0,0,0.12); display:flex; gap:6px; }
    .action-popup .popup-btn { padding:4px 8px; border-radius:4px; cursor:pointer; border:1px solid var(--border-color); background:var(--bg-accent); font-size:0.82rem; }
    .popup-icon { margin-left:6px; cursor:pointer; color:var(--text-secondary); }
    .action-popup .last-update { display:block; font-size:0.75rem; color:var(--text-muted); margin-top:6px; }
    .action-popup .last-update span { display:block; }
    </style>
</head>
<body>
    <!-- Header (split: top = title + timestamp, bottom = filters/actions) -->
    <header class="header">
        <div class="header-inner">
        <!-- Top row: title + timestamp + accordion toggle -->
        <div class="header-top">
            <div class="header-top-left">
                <h1 class="header-title"><i class="fas fa-chart-line"></i> Trading Scanner</h1>
            </div>
            <div class="header-top-right">
                <div class="last-refresh" id="pageLoadTime">Last Refresh: --</div>
                <button id="viewLogsBtnTop" class="icon-btn" title="View Logs"><i class="fas fa-file-alt"></i></button>
                <button id="darkModeToggleTop" class="theme-toggle" title="Toggle Theme"><i class="fas fa-moon"></i></button>
                <button id="filtersToggleBtn" class="accordion-toggle" aria-expanded="true" title="Toggle filters"><i class="fas fa-filter"></i></button>
            </div>
        </div>

        <!-- Bottom row: existing header content (filters, actions). This is collapsible. -->
        <div class="header-bottom" id="headerBottom">
            <div class="header-content">
                <div class="controls-section">
                    <div class="batch-controls toolbar">
                        <button id="runAllBtn" class="btn btn-primary">
                            <i class="fas fa-rocket"></i> Run All Scanners
                        </button>
                        <button id="stopAllBtn" class="btn btn-secondary" disabled>
                            <i class="fas fa-stop"></i> Stop All
                        </button>
                        <span style="opacity:0.6">|</span>
                        <button id="runRSIAllBtn" class="btn btn-secondary" title="Run/Stop RSI for all symbols">
                            <i class="fas fa-wave-square"></i> Run RSI All
                        </button>
                        <button id="runEMAAllBtn" class="btn btn-secondary" title="Run/Stop EMA for all symbols">
                            <i class="fas fa-chart-line"></i> Run EMA All
                        </button>
                        <button id="runDMAAllBtn" class="btn btn-secondary" title="Run/Stop DMA for all symbols">
                            <i class="fas fa-chart-bar"></i> Run DMA All
                        </button>
                        <button id="refreshSymbolsBtn" class="btn btn-secondary">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                    <!-- timeframe-selector moved to symbols panel-actions for compact layout -->
                    <!-- EMA/DMA as % moved to symbols panel header (top-right) -->
                    <div id="filters" style="display:flex; gap:0.5rem; align-items:center;">
                        <!-- Reco filters removed from top controls -- EMA/DMA % range moved to panel-actions -->
                    </div>
                    <!-- Moved viewLogsBtn & darkModeToggle to header-top for compact layout -->
                </div>
            </div>
        </div>
    </header>

        <!-- Loading State -->
        <div id="loadingState" class="panel" style="text-align: center; padding: 2rem;">
            <div class="loading-spinner"></div>
            <span style="margin-left: 1rem;">Loading symbols...</span>
        </div>

        <!-- Symbols Table -->
        <div id="symbolsContainer" class="panel" style="display: none;margin:1rem">
            <div class="panel-header">
                <h2 class="panel-title">
                    <i class="fas fa-table"></i> Symbols Dashboard
                </h2>
                <div class="panel-actions">
                    <span id="symbolStats">0 symbols loaded</span>
                     <span style="opacity:0.6">|</span>
                    <span id="progressInfo"></span>
                    <!-- Reco filter controls (populated dynamically from table unique Reco labels) -->
                    <div id="panelRecoFilters" style="display:flex; align-items:center; gap:0.5rem;"></div>
                        <!-- Moved EMA/DMA percent-range filter into panel-actions -->
                        <div style="margin-left:1rem; display:flex; align-items:center; gap:0.6rem;">
                            <label style="margin-right:0.25rem;">EMA/DMA % range:</label>
                            <input type="number" id="filter_pct_min" placeholder="-5" style="width:70px" />
                            <input type="number" id="filter_pct_max" placeholder="5" style="width:70px" />
                            <label><input type="checkbox" id="filter_apply_ema" checked/> EMA</label>
                            <label><input type="checkbox" id="filter_apply_dma" checked/> DMA</label>
                            <button id="applyFiltersBtn" class="btn btn-secondary">Apply</button>
                        </div>
                    <span style="opacity:0.6">|</span>
                    <div style="display:flex; align-items:center; gap:0.6rem;">
                        <label for="togglePct" style="margin:0; font-size:0.9rem; color:var(--text-secondary);">EMA/DMA as %</label>
                        <input type="checkbox" id="togglePct" />
                    </div>
                    <span style="opacity:0.6">|</span>
                    <div style="display:flex; align-items:center; gap:0.5rem;">
                        <label style="margin-right:0.25rem;">TimeFrame:</label>
                        <select id="timeframeSelect" class="form-select">
                            <option value="5mins">5 mins</option>
                            <option value="15mins" selected>15 mins</option>
                            <option value="30mins">30 mins</option>
                            <option value="1hour">1 hour</option>
                            <option value="daily">Daily</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="panel-content">
                <div class="toolbar" style="margin-bottom:0.5rem;">
                    <!-- Search removed as requested -->
                    <!-- EMA/DMA as % moved to symbols panel header (top-right) -->
                </div>
                <div class="table-scroll">
                    <table id="symbolsTable" class="symbols-table">
                        <thead id="symbolsTableHead"></thead>
                        <tbody id="symbolsTBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Log Viewer Modal -->
        <div id="logModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-file-alt"></i> Application Logs</h3>
                    <button id="closeLogModal" class="btn-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="controls-section">
                        <button id="clearLogsBtn" class="btn btn-secondary">Clear Logs</button>
                        <button id="refreshLogsBtn" class="btn btn-secondary">Refresh</button>
                        <select id="logLevelFilter" class="form-select">
                            <option value="all">All Levels</option>
                            <option value="error">Errors Only</option>
                            <option value="warning">Warnings+</option>
                            <option value="info">Info+</option>
                        </select>
                    </div>
                    <div id="logViewer" class="log-viewer">Loading logs...</div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div id="statusLeft">Ready</div>
            <div id="statusRight"><span id="currentTime"></span></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
    
    <script>
        // Global state
        let symbols = [];
    let scannerStates = {};
    let runningScans = new Set();
    let totalRunning = 0;
    let stopRequested = false; // stop flag for batch runs
    const stopRequestedFor = { rsi: false, ema: false, dma: false };
    let currentSort = { key: 'Symbol', dir: 'asc' };
    let showPctDiff = JSON.parse(localStorage.getItem('showPctDiff') || 'false');
    let isDarkMode = JSON.parse(localStorage.getItem('darkMode') || 'false');
    let chartInstance = null;
    // Cache combined chart data per symbol+timeframe so modal controls can re-render locally
    const chartCache = {};
    // Column index map for dynamic header columns
    let colIndexMap = {};
        // Modal progress toast handle (to update/clear persistent progress messages)
        let modalProgressToast = null;

        function showModalProgress(msg, severity = 'info') {
            try {
                // Clear existing persistent toast
                if (modalProgressToast) {
                    try { toastr.clear(modalProgressToast); } catch(e){}
                    modalProgressToast = null;
                }
                // Create a non-expiring toast
                modalProgressToast = toastr[severity](msg, null, { timeOut: 0, extendedTimeOut: 0, closeButton: true, tapToDismiss: false });
            } catch (e) { console.warn('showModalProgress failed', e); }
        }

        function clearModalProgress() {
            try {
                if (modalProgressToast) {
                    try { toastr.clear(modalProgressToast); } catch(e){}
                    modalProgressToast = null;
                }
            } catch (e) { /* ignore */ }
        }
        
        // Toastr configuration
        toastr.options = {
            "closeButton": true,
            "newestOnTop": true,
            "progressBar": true,
            "positionClass": "toast-bottom-right",
            "timeOut": "4000",
            "extendedTimeOut": "1000"
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', async function() {
            updateStatusBar();
            setInterval(updateTime, 1000);
            
            // Build the dynamic table header first so rows render into correct columns
            await buildDynamicHeader();
            await loadSymbols();
            setupEventListeners();
            // init toggles
            const pctEl = document.getElementById('togglePct');
            if (pctEl) {
                pctEl.checked = showPctDiff;
                // When toggling EMA/DMA percent view we must not re-render the entire table
                // (that causes mini-candles and other fields to be redrawn). Instead only
                // update the EMA/DMA cells in-place.
                pctEl.addEventListener('change', () => {
                    showPctDiff = pctEl.checked;
                    localStorage.setItem('showPctDiff', JSON.stringify(showPctDiff));
                    try { updateEmaDmaPctDisplay(); } catch(e) { console.warn('updateEmaDmaPctDisplay failed', e); }
                });
            }
            loadDarkModePreference();
            
            // Hide loading state and show symbols
            document.getElementById('loadingState').style.display = 'none';
            document.getElementById('symbolsContainer').style.display = 'flex';
            
            toastr.success('Dashboard loaded successfully!', 'Welcome');

            // Initialize page load timestamp in header-top
            const pageLoadEl = document.getElementById('pageLoadTime');
            if (pageLoadEl) {
                pageLoadEl.textContent = 'Last Refresh: ' + new Date().toLocaleString();
            }

            // Wire the filters accordion toggle (collapses/expands header-bottom)
            const filtersToggleBtn = document.getElementById('filtersToggleBtn');
            const headerBottom = document.getElementById('headerBottom');
            if (filtersToggleBtn && headerBottom) {
                filtersToggleBtn.addEventListener('click', function() {
                    const expanded = this.getAttribute('aria-expanded') === 'true';
                    this.setAttribute('aria-expanded', String(!expanded));
                    headerBottom.classList.toggle('collapsed');

                    // After toggling, recompute group header height for sticky stacking
                    setTimeout(function() {
                        const groupRow = document.querySelector('#symbolsTable thead tr#tableGroupHeader');
                        if (groupRow) {
                            const rect = groupRow.getBoundingClientRect();
                            document.documentElement.style.setProperty('--group-header-height', rect.height + 'px');
                        }
                        // Recompute header offsets for table stickiness
                        computeHeaderOffset();
                    }, 50);
                });
            }

                // Top-row buttons exist but are wired in setupEventListeners() to avoid duplicate handlers
                    const viewLogsBtnTop = document.getElementById('viewLogsBtnTop');
                    const darkModeToggleTop = document.getElementById('darkModeToggleTop');
        });

        // Compute header heights and set CSS variables so table headers stick below the page header
        function computeHeaderOffset() {
            try {
                const headerEl = document.querySelector('header.header');
                const headerInner = document.querySelector('.header-inner');
                let headerHeight = 0;
                if (headerEl) {
                    headerHeight = headerEl.getBoundingClientRect().height;
                } else if (headerInner) {
                    headerHeight = headerInner.getBoundingClientRect().height;
                }
                document.documentElement.style.setProperty('--header-height', headerHeight + 'px');

                // If a group header row exists, set --group-header-height; otherwise zero
                const groupRow = document.querySelector('#symbolsTable thead tr#tableGroupHeader');
                if (groupRow) {
                    const rect = groupRow.getBoundingClientRect();
                    document.documentElement.style.setProperty('--group-header-height', rect.height + 'px');
                } else {
                    document.documentElement.style.setProperty('--group-header-height', '0px');
                }
            } catch (e) { console.warn('computeHeaderOffset failed', e); }
        }

        // Build table header dynamically using configured periods from server
        async function buildDynamicHeader() {
            try {
                // Attempt to fetch config for RSI/EMA/DMA; fall back to sensible defaults
                const rsiRes = await fetch('/api/config/rsi');
                const emaRes = await fetch('/api/config/ema');
                const dmaRes = await fetch('/api/config/dma');
                const rsiCfg = rsiRes.ok ? await rsiRes.json() : {};
                const emaCfg = emaRes.ok ? await emaRes.json() : {};
                const dmaCfg = dmaRes.ok ? await dmaRes.json() : {};

                const rsi_periods = (rsiCfg && rsiCfg.rsi_periods) || [5,15,30];
                const ema_periods = (emaCfg && emaCfg.ema_periods) || [9,15];
                const dma_periods = (dmaCfg && dmaCfg.dma_periods) || [10,20,50,100,200];

                const thead = document.getElementById('symbolsTableHead');
                thead.innerHTML = '';
                const tr = document.createElement('tr');
                // base columns
                const baseCols = [ {k:'Symbol', t:'Symbol', cls:'symbol-col'}, {k:'CMP', t:'CMP'}, {k:'Reco', t:'Reco'}, {k:'Trend', t:'Trend'} ];
                let idx = 0;
                colIndexMap = {};
                baseCols.forEach(c => {
                    const th = document.createElement('th');
                    if (c.cls) th.className = c.cls;
                    th.setAttribute('data-key', c.k);
                    th.textContent = c.t;
                    // Add tooltip on Reco header explaining calculation
                    if (c.k === 'Reco') {
                        th.title = 'Reco = EMA(9/15) crossover (±2) + EMA confirmation vs longer EMA (±0.5) + CMP vs EMA200 (±1.5) + RSI(timeframe) (±1 / ±0.5)';
                    }
                    tr.appendChild(th);
                    colIndexMap[c.k] = idx++;
                });

                // RSI columns
                for (const p of rsi_periods) {
                    const key = `rsi_${p}`;
                    const th = document.createElement('th'); th.setAttribute('data-key', key); th.textContent = `RSI-${p}`; tr.appendChild(th); colIndexMap[key] = idx++;
                }

                // EMA columns
                for (const p of ema_periods) {
                    const key = `ema_${p}`;
                    const th = document.createElement('th'); th.setAttribute('data-key', key); th.textContent = `EMA-${p}`; tr.appendChild(th); colIndexMap[key] = idx++;
                }

                // DMA columns
                for (const p of dma_periods) {
                    const key = `dma_${p}`;
                    const th = document.createElement('th'); th.setAttribute('data-key', key); th.textContent = `DMA-${p}`; tr.appendChild(th); colIndexMap[key] = idx++;
                }

                // Actions
                const thActions = document.createElement('th'); thActions.textContent = 'Sync'; tr.appendChild(thActions); colIndexMap['Sync'] = idx++;

                thead.appendChild(tr);

            } catch (e) {
                console.warn('Failed to build dynamic header, falling back to static header', e);
            }
        }

        // Update offsets on resize and when content/layout changes
        window.addEventListener('resize', function() { computeHeaderOffset(); });
        // Also compute after initial load (in case called earlier)
        window.addEventListener('load', function() { computeHeaderOffset(); });

        // Wire timeframe selector to refresh mini-candles (debounced)
        try {
            const topTf = document.getElementById('timeframeSelect');
            if (topTf) topTf.addEventListener('change', debounce(() => { refreshAllMiniSparks(); computeHeaderOffset(); updateAllEmaForTimeframe(); }, 400));
        } catch (e) { /* ignore */ }

        // Load symbols from API
        async function loadSymbols() {
            try {
                updateStatusBar('Loading symbols...');
                // Retry with small backoff to survive cold-starts
                const maxAttempts = 3;
                let attempt = 0, response, data, lastErr;
                while (attempt < maxAttempts) {
                    try {
                        response = await fetch('/api/symbol-table', { cache: 'no-store' });
                        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        data = await response.json();
                        break; // success
                    } catch (err) {
                        lastErr = err;
                        attempt++;
                        if (attempt < maxAttempts) {
                            await new Promise(r => setTimeout(r, 400 * attempt));
                        }
                    }
                }
                if (!data) {
                    throw lastErr || new Error('Failed to load symbol table');
                }
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load symbol table');
                }
                
                symbols = data.symbols || [];
                
                // Initialize scanner states
                symbols.forEach(symbol => {
                    const symbolName = symbol.Symbol || symbol;
                    scannerStates[symbolName] = {
                        rsi: { status: 'idle', time: null, data: null },
                        ema: { status: 'idle', time: null, data: null },
                        dma: { status: 'idle', time: null, data: null }
                    };
                });
                
                renderSymbolsTable();
                updateSymbolStats();
                updateStatusBar('Symbols loaded successfully');
                
            } catch (error) {
                console.error('Failed to load symbols:', error);
                toastr.error('Failed to load symbols: ' + error.message, 'Error');
                updateStatusBar('Error loading symbols');
                
                // Show error state
                document.getElementById('loadingState').innerHTML = `
                    <div style="text-align: center; color: #ef4444;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <h3>Failed to load symbols</h3>
                        <p>${error && error.message ? error.message : 'Request failed'}</p>
                        <button onclick="location.reload()" class="btn btn-primary" style="margin-top: 1rem;">
                            <i class="fas fa-refresh"></i> Retry
                        </button>
                    </div>
                `;
            }
        }

        // Render symbols table
        // NOTE: To avoid triggering per-symbol API calls when the UI is re-ordered
        // (for example via sorting), reuse existing <tr id="row-..."> DOM nodes
        // where possible instead of recreating them. createTableRow() schedules
        // indicator refreshes for missing fields, so recreating rows on sort or
        // filter causes a flood of /api requests. Reordering existing nodes keeps
        // their state intact and prevents unnecessary network traffic.
        function renderSymbolsTable() {
            const tbody = document.getElementById('symbolsTBody');

            // Build sorted list based on currentSort
            const sorted = [...symbols].sort((a, b) => compareByKey(a, b, currentSort.key, currentSort.dir));

            // Capture existing rows so we can reuse DOM nodes and avoid re-running
            // the per-row initialization that may trigger API calls.
            const existingRows = new Map();
            tbody.querySelectorAll('tr').forEach(tr => {
                try {
                    const id = tr.id && tr.id.replace && tr.id.replace('row-','');
                    if (id) existingRows.set(id, tr);
                } catch (e) { /* ignore */ }
            });

            // Clear tbody without destroying nodes (we'll re-append reused nodes)
            while (tbody.firstChild) tbody.removeChild(tbody.firstChild);

            // Append rows in sorted order; reuse existing nodes when available
            sorted.forEach(item => {
                const symbolName = (item && item.Symbol) ? item.Symbol : item;
                const existing = existingRows.get(symbolName);
                if (existing) {
                    // Ensure row is visible by clearing inline display (filtering will handle hiding)
                    existing.style.display = '';
                    tbody.appendChild(existing);
                } else {
                    // Only create a new row when it doesn't already exist (initial load)
                    tbody.appendChild(createTableRow(item));
                }
            });

            // wire header sorting
            document.querySelectorAll('#symbolsTable thead th[data-key]')
                .forEach(th => {
                    th.onclick = () => {
                        const key = th.getAttribute('data-key');
                        if (currentSort.key === key) {
                            currentSort.dir = currentSort.dir === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort.key = key; currentSort.dir = 'asc';
                        }
                        renderSymbolsTable();
                    }
                });

            // wire search input (if present)
            const search = document.getElementById('tableSearch');
            if (search && !search._wired) {
                search._wired = true;
                search.addEventListener('input', () => applyFilter(search.value || ''));
            }

            // apply advanced filters after rendering
            applyFilters();
            // build panel-level Reco filters based on current table content
            try { buildPanelRecoFilters(); } catch(e) { /* ignore */ }
        }

        // Build panel-level Reco filter checkboxes dynamically from distinct Reco labels
        function buildPanelRecoFilters() {
            try {
                const container = document.getElementById('panelRecoFilters');
                if (!container) return;
                // Simplified: always provide Bull / Neutral / Bear checkboxes
                container.innerHTML = '';
                const title = document.createElement('span'); title.style.opacity = '0.8'; title.style.fontSize = '0.9rem'; title.textContent = 'Reco:';
                container.appendChild(title);
                // Provide a dedicated filter for rows where Reco is missing ('-').
                // Render '-' as the last item per request.
                const categories = ['Bull','Neutral','Bear','-'];
                categories.forEach(lbl => {
                    // Use a safe id for the '-' option
                    const idKey = (lbl === '-') ? 'dash' : lbl.toLowerCase();
                    const id = `panel_reco_${idKey}`;
                    const labelEl = document.createElement('label');
                    labelEl.style.display = 'flex'; labelEl.style.alignItems = 'center'; labelEl.style.gap = '0.25rem';
                    const chk = document.createElement('input'); chk.type = 'checkbox'; chk.id = id; chk.checked = true;
                    chk.addEventListener('change', () => { applyFilters(); });
                    const span = document.createElement('span'); span.style.fontSize = '0.9rem'; span.textContent = ' ' + lbl;
                    labelEl.appendChild(chk); labelEl.appendChild(span);
                    container.appendChild(labelEl);
                });
            } catch (e) { console.warn('buildPanelRecoFilters failed', e); }
        }

        // Draw small candlesticks into a canvas for last 5 points
        function drawMiniCandles(canvas, ohlcArray) {
            try {
                if (!canvas || !Array.isArray(ohlcArray) || ohlcArray.length === 0) return;
                const ctx = canvas.getContext('2d');
                // Handle devicePixelRatio to ensure crisp rendering and force a full redraw
                const dpr = window.devicePixelRatio || 1;
                // CSS size (may be set via style) -> use getBoundingClientRect for accurate CSS pixels
                const rect = canvas.getBoundingClientRect();
                const cssW = Math.max(1, Math.round(rect.width));
                const cssH = Math.max(1, Math.round(rect.height));
                // Set actual canvas pixel size for DPR and clear
                if (canvas.width !== Math.round(cssW * dpr) || canvas.height !== Math.round(cssH * dpr)) {
                    canvas.width = Math.round(cssW * dpr);
                    canvas.height = Math.round(cssH * dpr);
                    canvas.style.width = cssW + 'px';
                    canvas.style.height = cssH + 'px';
                }
                ctx.setTransform(1,0,0,1,0,0);
                ctx.scale(dpr, dpr);
                const W = cssW; const H = cssH;
                ctx.clearRect(0,0,W,H);
                // Use last 5
                const data = ohlcArray.slice(-5);
                // Build min/max
                const lows = data.map(d => d[2]);
                const highs = data.map(d => d[1]);
                const minV = Math.min(...lows); const maxV = Math.max(...highs);
                const pad = (maxV - minV) * 0.08 || 1;
                const scale = (v) => H - 2 - ((v - (minV - pad)) / ((maxV + pad) - (minV - pad))) * (H - 4);
                const barW = Math.max(4, Math.floor(W / data.length) - 4);
                const gap = (W - (barW * data.length)) / (data.length + 1);
                let x = gap;
                for (const d of data) {
                    const o = Number(d[0]), h = Number(d[1]), l = Number(d[2]), c = Number(d[3]);
                    const yO = scale(o), yH = scale(h), yL = scale(l), yC = scale(c);
                    const isBull = c >= o;
                    ctx.strokeStyle = isBull ? '#10b981' : '#ef4444';
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.lineWidth = 1.2;
                    // wick
                    ctx.beginPath(); ctx.moveTo(x + barW/2, yH); ctx.lineTo(x + barW/2, yL); ctx.stroke();
                    // body
                    const top = Math.min(yO, yC); const height = Math.max(1, Math.abs(yC - yO));
                    if (isBull) {
                        ctx.fillRect(x, top, barW, height);
                    } else {
                        ctx.fillRect(x, top, barW, height);
                    }
                    x += barW + gap;
                }
            } catch (e) { console.warn('drawMiniCandles failed', e); }
        }

        // Load mini spark for a symbol using /api/chart-data (prefer OHLC produced in chartData)
        async function loadMiniSpark(symbol) {
            try {
                const tf = document.getElementById('timeframeSelect')?.value || '15mins';
                const q = `?timeframe=${encodeURIComponent(tf)}`;
                let payload = null;

                // Prefer OHLC-only endpoint which returns resampled OHLC (does not recompute indicators)
                try {
                    const ohlcRes = await fetch(`/api/chart-data/ohlc/${symbol}${q}`, { cache: 'no-store' }).catch(() => null);
                    if (ohlcRes && ohlcRes.ok) {
                        const p = await ohlcRes.json().catch(() => null);
                        if (p && p.chartData && Array.isArray(p.chartData.datasets) && p.chartData.datasets.length > 0) {
                            payload = p;
                        }
                    }
                } catch (e) { /* ignore */ }

                // Do NOT fallback to indicator endpoints here. For mini-candles we only need OHLC
                // If OHLC isn't available, draw placeholder — avoid triggering EMA/DMA/RSI computations.

                const canvas = document.getElementById(`mini-${symbol}`);
                if (!canvas) return false;
                // Debug: show which source provided data
                try { console.debug(`[mini] loadMiniSpark: symbol=${symbol} payloadSource=${payload && payload.scannerType ? payload.scannerType : 'ohlc'} datasets=${payload && payload.chartData && Array.isArray(payload.chartData.datasets) ? payload.chartData.datasets.length : 0}`); } catch(e){}

                if (!payload || !payload.chartData || !Array.isArray(payload.chartData.datasets) || payload.chartData.datasets.length === 0) {
                    // No data found: clear canvas and draw muted placeholder
                    try {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0,0,canvas.width,canvas.height);
                        ctx.fillStyle = 'rgba(107,114,128,0.12)';
                        ctx.fillRect(0,0,canvas.width,canvas.height);
                        ctx.fillStyle = 'rgba(55,65,81,0.6)';
                        ctx.font = '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('-', canvas.width/2, canvas.height/2);
                    } catch (e) { /* ignore drawing errors */ }
                    return false;
                }

                // Find OHLC dataset
                const ohlcDs = payload.chartData.datasets.find(d => d.label && d.label.toUpperCase() === 'OHLC');
                let ohlcArray = null;
                if (ohlcDs && Array.isArray(ohlcDs.data) && ohlcDs.data.length > 0) {
                    if (Array.isArray(ohlcDs.data[0])) ohlcArray = ohlcDs.data.slice();
                    else if (typeof ohlcDs.data[0] === 'object' && ('c' in ohlcDs.data[0] || 'close' in ohlcDs.data[0])) {
                        ohlcArray = ohlcDs.data.map(pt => [pt.o || pt[0] || pt.open, pt.h || pt[1] || pt.high, pt.l || pt[2] || pt.low, pt.c || pt[3] || pt.close]);
                    }
                }

                // fallback: close dataset
                if (!ohlcArray) {
                    const closeDs = payload.chartData.datasets.find(d => d.label && /close/i.test(d.label));
                    if (closeDs && Array.isArray(closeDs.data) && closeDs.data.length > 0) {
                        ohlcArray = closeDs.data.map(v => [v, v, v, v]);
                    }
                }

                if (!ohlcArray) {
                    // draw placeholder
                    try {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0,0,canvas.width,canvas.height);
                        ctx.fillStyle = 'rgba(107,114,128,0.12)'; ctx.fillRect(0,0,canvas.width,canvas.height);
                        ctx.fillStyle = 'rgba(55,65,81,0.6)'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('-', canvas.width/2, canvas.height/2);
                    } catch(e){}
                    return false;
                }

                // Successful draw
                // Force clear before draw to ensure redraw on all browsers
                try { const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); } catch(e){ }
                drawMiniCandles(canvas, ohlcArray);
                try { console.debug(`[mini] drew mini-candles for ${symbol} (points=${ohlcArray.length})`); } catch(e){}
                return true;
            } catch (e) { console.warn('loadMiniSpark failed', e); return false; }
        }

        // Refresh all mini sparks (used when timeframe selector changes)
        // NOTE: lazy-loading via IntersectionObserver caused issues for some users.
        // Roll back to immediate loading: always attempt to load the mini spark when requested.
        async function refreshAllMiniSparks() {
            const list = symbols.map(s => s.Symbol || s);
            if (!list || list.length === 0) return;
            const tf = document.getElementById('timeframeSelect')?.value || '15mins';
            try {
                // Show persistent progress so user knows refresh is ongoing
                showModalProgress(`Refreshing Trend mini-candles (${tf})...`, 'info');
            } catch (e) { /* ignore */ }

            // Launch all loads in parallel and wait for completion; count successful draws
            const promises = list.map(sym => {
                try { return loadMiniSpark(sym).catch(() => false); } catch (e) { return Promise.resolve(false); }
            });
            try {
                const results = await Promise.all(promises);
                const successCount = results.filter(Boolean).length;
                try { clearModalProgress(); } catch(e){}
                if (successCount === list.length) {
                    try { toastr.success(`Trend mini-candles updated (${successCount}/${list.length})`, 'Updated'); } catch(e){}
                } else if (successCount > 0) {
                    try { toastr.warning(`Trend mini-candles partially updated (${successCount}/${list.length})`, 'Partial'); } catch(e){}
                } else {
                    try { toastr.error('No mini-candle data available for selected timeframe', 'No Data'); } catch(e){}
                }
            } catch (e) {
                try { clearModalProgress(); } catch(e){}
                try { toastr.warning('Some mini-candles failed to update', 'Partial'); } catch(e){}
            }
        }

        // observeMiniCanvas no longer uses IntersectionObserver. Call loadMiniSpark immediately.
        const miniObserver = null;

        function observeMiniCanvas(symbol) {
            try {
                loadMiniSpark(symbol).catch(() => {});
            } catch (e) { /* ignore */ }
        }

        // Compute simple EMA for a numeric array (close prices). Returns array of EMA values (same length) or null.
        function computeEMAArray(values, period) {
            if (!Array.isArray(values) || values.length === 0 || period <= 0) return null;
            const out = [];
            const k = 2 / (period + 1);
            // start with SMA for first period if available
            let sma = null;
            if (values.length >= period) {
                const slice = values.slice(0, period).map(v => Number(v)).filter(v => !isNaN(v));
                if (slice.length === period) sma = slice.reduce((a,b)=>a+b,0)/period;
            }
            let prev = sma !== null ? sma : Number(values[0]) || 0;
            for (let i=0;i<values.length;i++) {
                const v = Number(values[i]);
                if (isNaN(v)) { out.push(null); continue; }
                if (i < period-1 && sma === null) {
                    // not enough data yet
                    out.push(null);
                    prev = v;
                    continue;
                }
                if (i === period-1 && sma !== null) {
                    prev = sma;
                }
                const ema = (v - prev) * k + prev;
                out.push(ema);
                prev = ema;
            }
            return out;
        }

        // Update EMA cells for a single symbol by fetching OHLC resampled to timeframe and computing ema9/ema15
        async function updateEmaForSymbol(symbol, timeframe) {
            try {
                if (!colIndexMap || !colIndexMap['ema_9'] || !colIndexMap['ema_15']) return false;
                const res = await fetch(`/api/chart-data/ohlc/${encodeURIComponent(symbol)}?timeframe=${encodeURIComponent(timeframe)}`, { cache: 'no-store' }).catch(() => null);
                if (!res || !res.ok) return false;
                const payload = await res.json().catch(() => null);
                if (!payload || !payload.chartData || !Array.isArray(payload.chartData.datasets)) return false;
                // Extract Close dataset
                let closeDs = payload.chartData.datasets.find(d => d.label && /close/i.test(d.label));
                if (!closeDs) closeDs = payload.chartData.datasets.find(d => d.label && !/ohlc/i.test(d.label) && Array.isArray(d.data));
                let closes = [];
                if (closeDs && Array.isArray(closeDs.data)) {
                    closes = closeDs.data.map(pt => {
                        if (Array.isArray(pt)) return Number(pt[3] || pt[0] || null);
                        if (typeof pt === 'object') return Number(pt.c ?? pt.close ?? null);
                        return Number(pt);
                    }).filter(v => !isNaN(v));
                }
                if (!closes || closes.length === 0) return false;
                const ema9Arr = computeEMAArray(closes, 9);
                const ema15Arr = computeEMAArray(closes, 15);
                const ema9 = ema9Arr ? ema9Arr[ema9Arr.length-1] : null;
                const ema15 = ema15Arr ? ema15Arr[ema15Arr.length-1] : null;

                const row = document.getElementById(`row-${symbol}`);
                if (!row) return false;
                const cells = row.querySelectorAll('td');
                const idx9 = colIndexMap['ema_9'];
                const idx15 = colIndexMap['ema_15'];
                // compute cmp for pct display if needed
                const cmpCell = cells[1];
                let cmp = NaN;
                if (cmpCell) {
                    const attr = cmpCell.getAttribute && cmpCell.getAttribute('data-cmp');
                    cmp = (attr !== null && attr !== undefined) ? parseFloat(attr) : NaN;
                }

                const formatVal = (v) => (v === null || v === undefined || isNaN(v)) ? '<span class="cell-muted">-</span>' : Number(v).toFixed(2);
                const formatPct = (v) => {
                    if (v === null || v === undefined || isNaN(v) || isNaN(cmp) || cmp === 0) return '<span class="cell-muted">-</span>';
                    const d = ((v - cmp)/cmp)*100; const cls = (cmp > v) ? 'percent-pos' : (cmp < v ? 'percent-neg' : 'percent-neutral');
                    return `<span class="${cls}" data-pct="${d}">${d.toFixed(2)}%</span>`;
                };

                // Decide color based on ema9 vs ema15
                let cls9 = 'percent-neutral', cls15 = 'percent-neutral';
                if (!isNaN(ema9) && !isNaN(ema15)) {
                    if (ema9 > ema15) { cls9 = cls15 = 'percent-pos'; }
                    else if (ema9 < ema15) { cls9 = cls15 = 'percent-neg'; }
                    else { cls9 = cls15 = 'percent-neutral'; }
                }

                // Update DOM cells if indices present
                if (idx9 !== undefined && cells[idx9]) {
                    cells[idx9].innerHTML = showPctDiff ? formatPct(ema9) : `<span class="${cls9}">${formatVal(ema9)}</span>`;
                }
                if (idx15 !== undefined && cells[idx15]) {
                    cells[idx15].innerHTML = showPctDiff ? formatPct(ema15) : `<span class="${cls15}">${formatVal(ema15)}</span>`;
                }

                // Mark reco as pending for this row since EMA values changed; schedule recompute
                try {
                    const recoCell = row.querySelector('.reco-cell');
                    if (recoCell) {
                        recoCell.setAttribute('data-reco-state', 'pending');
                        setTimeout(() => { updateRecoForRow(symbol); }, 80);
                    }
                } catch (e) { /* ignore */ }

                return true;
            } catch (e) { console.warn('updateEmaForSymbol failed', symbol, e); return false; }
        }

        // Concurrency helper to run promises with limited parallelism
        async function runWithConcurrency(items, workerFn, limit = 6) {
            const results = [];
            const executing = new Set();
            for (const it of items) {
                const p = Promise.resolve().then(() => workerFn(it));
                results.push(p);
                executing.add(p);
                p.then(() => executing.delete(p)).catch(() => executing.delete(p));
                if (executing.size >= limit) await Promise.race(executing);
            }
            return Promise.all(results);
        }

        async function updateAllEmaForTimeframe() {
            try {
                const tf = document.getElementById('timeframeSelect')?.value || '15mins';
                const list = symbols.map(s => s.Symbol || s);
                if (!list || list.length === 0) return;
                // Show small progress toast
                showModalProgress(`Updating EMA(9/15) for timeframe ${tf}...`);
                await runWithConcurrency(list, async (sym) => { await updateEmaForSymbol(sym, tf); }, 6);
                clearModalProgress();
                toastr.success('EMA(9/15) updated to selected timeframe', 'EMA Updated');
                // After EMA values updated, attempt to populate missing DMA values for visible rows
                try { await ensureDmaForVisibleRows(); } catch(e) { /* ignore */ }
                try { updateAllRecoLabels(); } catch(e) { /* ignore */ }
            } catch (e) {
                try { clearModalProgress(); } catch(e){}
                console.warn('updateAllEmaForTimeframe failed', e);
            }
        }

        // Update reco for a single row (compute after other indicators have been updated)
        async function updateRecoForRow(symbol) {
            try {
                const row = document.getElementById(`row-${symbol}`);
                if (!row) return;
                const cell = row.querySelector('.reco-cell');
                if (!cell) return;
                // If already computed and not pending, skip
                const state = cell.getAttribute('data-reco-state');
                if (state === 'done') return;
                // Determine presence of indicators in the row (must have at least one RSI, one EMA and one DMA)
                const hasIndicator = (prefix) => {
                    try {
                        const cols = Object.keys(colIndexMap || {}).filter(k => k.startsWith(prefix));
                        if (!cols || cols.length === 0) return false;
                        for (const k of cols) {
                            const idx = colIndexMap[k];
                            const c = row.querySelectorAll('td')[idx];
                            if (!c) continue;
                            const v = parseNumericFromCell(c, parseFloat(row.querySelectorAll('td')[1]?.getAttribute('data-cmp')||NaN));
                            if (!isNaN(v)) return true;
                        }
                        return false;
                    } catch (e) { return false; }
                };

                const hasRsi = hasIndicator('rsi_');
                const hasEma = hasIndicator('ema_');
                const hasDma = hasIndicator('dma_');

                // If any scanner for this symbol is currently running, show spinner
                const runningAny = (scannerStates[symbol] && (scannerStates[symbol].rsi?.status === 'running' || scannerStates[symbol].ema?.status === 'running' || scannerStates[symbol].dma?.status === 'running')) || false;
                if (runningAny) {
                    cell.innerHTML = '<span class="reco-neutral"><i class="fas fa-spinner fa-spin" style="margin-right:6px"></i></span>';
                    cell.setAttribute('data-reco-state', 'running');
                    return;
                }

                // Only compute reco when all three indicator groups are available
                if (hasRsi && hasEma && hasDma) {
                    const score = computeRecoScore(symbol);
                    cell.innerHTML = scoreToLabelHtml(score);
                    try { cell.title = buildRecoTooltip(symbol, score); } catch(e) { /* ignore */ }
                    cell.setAttribute('data-reco-state', 'done');
                } else {
                    // Not all indicators available: show neutral placeholder and remain pending
                    cell.innerHTML = '<span class="reco-neutral">-</span>';
                    cell.setAttribute('data-reco-state', 'pending');
                }
            } catch (e) { console.warn('updateRecoForRow failed', symbol, e); }
        }

        // Recompute Reco labels for all visible rows (use computeRecoScore)
        // Runs updates asynchronously per-row to allow indicator fetches/updates to complete
        function updateAllRecoLabels() {
            try {
                const tbody = document.getElementById('symbolsTBody');
                if (!tbody) return;
                const rows = Array.from(tbody.querySelectorAll('tr'));
                // schedule updates in small batches to avoid blocking UI
                const batchSize = 20;
                for (let i = 0; i < rows.length; i += batchSize) {
                    const batch = rows.slice(i, i + batchSize);
                    // schedule next batch in next tick so DOM updates can settle
                    setTimeout(() => {
                        batch.forEach(tr => {
                            try {
                                const sym = tr.id && tr.id.replace && tr.id.replace('row-','');
                                if (!sym) return;
                                // if cell is pending or not computed, update it
                                const cell = tr.querySelector('.reco-cell');
                                if (!cell) return;
                                const state = cell.getAttribute('data-reco-state');
                                if (state !== 'done') {
                                    // compute after small delay to allow other updates to finish
                                    setTimeout(() => { updateRecoForRow(sym); }, 50);
                                }
                            } catch(e) { /* ignore per-row errors */ }
                        });
                    }, 0);
                }
                // Rebuild panel-level Reco filters to reflect distinct labels currently present
                try { buildPanelRecoFilters(); } catch(e) { /* ignore */ }
            } catch (e) { console.warn('updateAllRecoLabels failed', e); }
        }

        // Helper: parse numeric from a cell's content or data-original/data-pct attributes
        function parseNumericFromCell(cell, cmpForPctFallback) {
            try {
                if (!cell) return NaN;
                // Prefer data-original if we've stored it before
                const orig = cell.getAttribute && cell.getAttribute('data-original');
                if (orig !== null && orig !== undefined && orig !== '') {
                    const n = parseFloat(orig);
                    if (!isNaN(n)) return n;
                }
                // If there's an element with data-pct, reconstruct if cmp available
                const pctEl = cell.querySelector && cell.querySelector('[data-pct]');
                if (pctEl) {
                    const pct = parseFloat(pctEl.getAttribute('data-pct'));
                    if (!isNaN(pct) && cmpForPctFallback && !isNaN(cmpForPctFallback) && cmpForPctFallback !== 0) {
                        return cmpForPctFallback * (1 + pct / 100);
                    }
                }
                // Otherwise try to parse visible text (strip % and non-numeric)
                let txt = cell.innerText || '';
                txt = txt.replace('%','').replace(/[^0-9.\-]/g,'');
                const v = parseFloat(txt);
                return isNaN(v) ? NaN : v;
            } catch (e) { return NaN; }
        }

        // Helper: attempt to extract a Date object from scanner payload/result
        function extractTimestampFromResult(obj) {
            try {
                if (!obj || typeof obj !== 'object') return null;
                // Common keys that may contain timestamp/date or epoch
                const keys = ['last_ts','last_timestamp','last_update','timestamp','ts','time','updated_at','last'];
                for (const k of keys) {
                    if (obj[k] !== undefined && obj[k] !== null) {
                        const v = obj[k];
                        // if numeric and looks like epoch seconds or ms
                        if (typeof v === 'number') {
                            // assume seconds if value is < 1e12
                            const ms = (v < 1e12) ? (v * 1000) : v;
                            const d = new Date(ms);
                            if (!isNaN(d.getTime())) return d;
                        }
                        if (typeof v === 'string') {
                            // try ISO parse
                            const d = new Date(v);
                            if (!isNaN(d.getTime())) return d;
                            // try numeric string
                            const n = Number(v);
                            if (!isNaN(n)) {
                                const ms = (n < 1e12) ? (n * 1000) : n;
                                const d2 = new Date(ms);
                                if (!isNaN(d2.getTime())) return d2;
                            }
                        }
                    }
                }
                // Recurse into nested objects `data` or `payload` etc.
                if (obj.data && typeof obj.data === 'object') {
                    const r = extractTimestampFromResult(obj.data);
                    if (r) return r;
                }
                if (obj.payload && typeof obj.payload === 'object') {
                    const r = extractTimestampFromResult(obj.payload);
                    if (r) return r;
                }
            } catch(e) { /* ignore parse errors */ }
            return null;
        }

        // Helper: convert selected timeframe string to minutes (used for timeframe-aware indicators)
        function getTimeframeMinutes() {
            try {
                const tf = document.getElementById('timeframeSelect')?.value || '15mins';
                if (/^(\d+)min?s?$/.test(tf)) return parseInt(tf.match(/^(\d+)/)[1], 10);
                if (/^1hour$/.test(tf) || /^1h$/.test(tf)) return 60;
                if (/^daily$/.test(tf) || /^1d$/.test(tf)) return 1440;
                // fallback: parse leading number
                const m = tf.match(/(\d+)/);
                return m ? parseInt(m[1], 10) : 15;
            } catch (e) { return 15; }
        }

        // Update only EMA/DMA cells in-place to toggle between numeric and percent view.
        function updateEmaDmaPctDisplay() {
            try {
                const tbody = document.getElementById('symbolsTBody');
                if (!tbody) return;
                const emaKeys = Object.keys(colIndexMap).filter(k => k.startsWith('ema_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
                const dmaKeys = Object.keys(colIndexMap).filter(k => k.startsWith('dma_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));

                // For each row, update EMA/DMA cells only
                tbody.querySelectorAll('tr').forEach(tr => {
                    try {
                        const cells = tr.querySelectorAll('td');
                        if (!cells || cells.length === 0) return;
                        const cmpAttr = cells[1] && cells[1].getAttribute ? cells[1].getAttribute('data-cmp') : null;
                        const cmp = (cmpAttr !== null && cmpAttr !== undefined) ? parseFloat(cmpAttr) : parseFloat((cells[1] && (cells[1].innerText||'').replace(/[^0-9.\-]/g,'')) || NaN);

                        // First handle EMA 9 and 15 together for shared coloring
                        const idx9 = colIndexMap['ema_9'];
                        const idx15 = colIndexMap['ema_15'];
                        let ema9Val = NaN, ema15Val = NaN;
                        if (idx9 !== undefined && cells[idx9]) ema9Val = parseNumericFromCell(cells[idx9], cmp);
                        if (idx15 !== undefined && cells[idx15]) ema15Val = parseNumericFromCell(cells[idx15], cmp);

                        // Determine shared class
                        let sharedCls = 'percent-neutral';
                        if (!isNaN(ema9Val) && !isNaN(ema15Val)) {
                            if (ema9Val > ema15Val) sharedCls = 'percent-pos';
                            else if (ema9Val < ema15Val) sharedCls = 'percent-neg';
                        }

                        // Helper to set cell content (numeric or pct) and preserve original numeric in data-original
                        const setCellToPct = (cell, numericVal) => {
                            if (!cell) return;
                            if (isNaN(numericVal) || isNaN(cmp) || cmp === 0) {
                                cell.innerHTML = '<span class="cell-muted">-</span>';
                                return;
                            }
                            // store original numeric for restoration
                            cell.setAttribute('data-original', String(numericVal));
                            const d = ((numericVal - cmp)/cmp) * 100;
                            // choose class: for EMA-9/15 caller will set sharedCls by wrapping span later
                            const cls = (cell === cells[idx9] || cell === cells[idx15]) ? sharedCls : (cmp > numericVal ? 'percent-pos' : (cmp < numericVal ? 'percent-neg' : 'percent-neutral'));
                            cell.innerHTML = `<span class="${cls}" data-pct="${d}">${d.toFixed(2)}%</span>`;
                        };

                        const setCellToNumeric = (cell) => {
                            if (!cell) return;
                            // prefer stored original
                            const orig = cell.getAttribute && cell.getAttribute('data-original');
                            let numericVal = NaN;
                            if (orig !== null && orig !== undefined && orig !== '') numericVal = parseFloat(orig);
                            // if no stored original, try reconstructing from pct
                            if (isNaN(numericVal)) {
                                const pctEl = cell.querySelector && cell.querySelector('[data-pct]');
                                if (pctEl && !isNaN(cmp) && cmp !== 0) {
                                    const pct = parseFloat(pctEl.getAttribute('data-pct'));
                                    if (!isNaN(pct)) numericVal = cmp * (1 + pct/100);
                                }
                            }
                            if (isNaN(numericVal)) {
                                // fallback: attempt parse of visible text
                                const txt = (cell.innerText||'').replace('%','').replace(/[^0-9.\-]/g,'');
                                numericVal = parseFloat(txt);
                            }
                            if (isNaN(numericVal)) { cell.innerHTML = '<span class="cell-muted">-</span>'; return; }
                            // decide class: for EMA-9/15 use sharedCls, otherwise cmp-relative
                            const cls = (cell === cells[idx9] || cell === cells[idx15]) ? sharedCls : (isNaN(cmp) ? 'percent-neutral' : (cmp > numericVal ? 'percent-pos' : (cmp < numericVal ? 'percent-neg' : 'percent-neutral')));
                            cell.setAttribute('data-original', String(numericVal));
                            cell.innerHTML = `<span class="${cls}">${numericVal.toFixed(2)}</span>`;
                        };

                        // Toggle conversion
                        if (showPctDiff) {
                            // convert EMA cells
                            emaKeys.forEach(k => {
                                const idx = colIndexMap[k];
                                const cell = cells[idx];
                                if (!cell) return;
                                // for ema_9/15 we already have computed numeric values; else parse
                                let num = NaN;
                                if (k === 'ema_9') num = ema9Val;
                                else if (k === 'ema_15') num = ema15Val;
                                if (isNaN(num)) num = parseNumericFromCell(cell, cmp);
                                setCellToPct(cell, num);
                            });
                            // convert DMA cells
                            dmaKeys.forEach(k => {
                                const idx = colIndexMap[k];
                                const cell = cells[idx];
                                if (!cell) return;
                                const num = parseNumericFromCell(cell, cmp);
                                setCellToPct(cell, num);
                            });
                        } else {
                            // restore numeric view
                            emaKeys.forEach(k => {
                                const idx = colIndexMap[k];
                                const cell = cells[idx];
                                if (!cell) return;
                                setCellToNumeric(cell);
                            });
                            dmaKeys.forEach(k => {
                                const idx = colIndexMap[k];
                                const cell = cells[idx];
                                if (!cell) return;
                                setCellToNumeric(cell);
                            });
                        }
                    } catch (e) { /* ignore row-level errors */ }
                });
            } catch (e) { console.warn('updateEmaDmaPctDisplay failed', e); }
        }

        // Compute numeric recommendation score for a symbol (used for sorting)
        // This function is timeframe-aware: it will read RSI for the selected timeframe
        // (e.g. rsi_15 when timeframe=15mins). EMA crossover is assumed to be updated
        // into the ema_9/ema_15 cells for the current timeframe by updateAllEmaForTimeframe().
        function computeRecoScore(symbolData) {
            const safeNum = (v) => {
                if (v === null || v === undefined) return null;
                if (typeof v === 'number') return v;
                const s = String(v).replace(/[^0-9.\-]/g, '');
                const n = parseFloat(s);
                return isNaN(n) ? null : n;
            };

            // symbolData can be either the API object or the symbol name string
            // determine timeframe-specific RSI key
            const tfMin = getTimeframeMinutes();
            const rsiKey = `rsi_${tfMin}`;
            let cmp = null, ema9 = null, ema15 = null, ema65 = null, ema200 = null, rsi_tf = null;
            if (typeof symbolData === 'string') {
                // symbol name provided; attempt DOM fallback
                const sym = symbolData;
                const row = document.getElementById(`row-${sym}`);
                if (row) {
                    const cells = row.querySelectorAll('td');
                    // CMP 1, RSI15 3, EMA9 6, EMA15 7, EMA65 8, EMA200 9
                    const cmpCell = cells[1];
                    if (cmpCell) {
                        const attr = cmpCell.getAttribute && cmpCell.getAttribute('data-cmp');
                        cmp = (attr !== null && attr !== undefined) ? parseFloat(attr) : safeNum(cmpCell.innerText);
                    }
                    const readIndicator = (cellIdx) => {
                        const c = cells[cellIdx];
                        if (!c) return null;
                        // Use parseNumericFromCell which handles data-original and data-pct reconstruction
                        const n = parseNumericFromCell(c, cmp);
                        if (!isNaN(n)) return n;
                        return safeNum(c.innerText);
                    };
                    // dynamic rsi index fallback: prefer column map if available
                    const rsiIdx = (colIndexMap && colIndexMap[rsiKey] !== undefined) ? colIndexMap[rsiKey] : 3;
                    rsi_tf = readIndicator(rsiIdx);
                    ema9 = readIndicator(colIndexMap['ema_9'] !== undefined ? colIndexMap['ema_9'] : 6);
                    ema15 = readIndicator(colIndexMap['ema_15'] !== undefined ? colIndexMap['ema_15'] : 7);
                    ema65 = readIndicator(colIndexMap['ema_65'] !== undefined ? colIndexMap['ema_65'] : 8);
                    ema200 = readIndicator(colIndexMap['ema_200'] !== undefined ? colIndexMap['ema_200'] : 9);
                }
            } else {
                // object from API
                cmp = safeNum(symbolData.CMP || symbolData.cmp || symbolData['CMP']);
                ema9 = safeNum(symbolData.ema_9);
                ema15 = safeNum(symbolData.ema_15);
                ema65 = safeNum(symbolData.ema_65) || safeNum(symbolData.ema_21) || null;
                ema200 = safeNum(symbolData.ema_200) || safeNum(symbolData.dma_200) || null;
                // timeframe-specific RSI key lookup
                rsi_tf = safeNum(symbolData[rsiKey]);

                // If missing numeric fields, try DOM fallback using symbol field
                if ((ema9 === null || ema15 === null || ema65 === null) && (symbolData.Symbol || symbolData.symbol)) {
                    const row = document.getElementById(`row-${symbolData.Symbol || symbolData.symbol}`);
                    if (row) {
                        const cells = row.querySelectorAll('td');
                        const cmpCell = cells[1];
                        if (cmpCell) {
                            const attr = cmpCell.getAttribute && cmpCell.getAttribute('data-cmp');
                            cmp = cmp || ((attr !== null && attr !== undefined) ? parseFloat(attr) : safeNum(cmpCell.innerText));
                        }
                        const readIndicator = (cellIdx) => {
                            const c = cells[cellIdx];
                            if (!c) return null;
                            const n = parseNumericFromCell(c, cmp);
                            if (!isNaN(n)) return n;
                            return safeNum(c.innerText);
                        };
                        const rsiIdx = (colIndexMap && colIndexMap[rsiKey] !== undefined) ? colIndexMap[rsiKey] : 3;
                        rsi_tf = rsi_tf || readIndicator(rsiIdx);
                        ema9 = ema9 || readIndicator(colIndexMap['ema_9'] !== undefined ? colIndexMap['ema_9'] : 6);
                        ema15 = ema15 || readIndicator(colIndexMap['ema_15'] !== undefined ? colIndexMap['ema_15'] : 7);
                        ema65 = ema65 || readIndicator(colIndexMap['ema_65'] !== undefined ? colIndexMap['ema_65'] : 8);
                        ema200 = ema200 || readIndicator(colIndexMap['ema_200'] !== undefined ? colIndexMap['ema_200'] : 9);
                    }
                }
            }

            let score = 0;
            // EMA crossover on selected timeframe (ema_9 vs ema_15)
            // Small deadband: if difference is tiny (< deadband) treat as equal to avoid flip-flopping
            const emaDeadband = 0.5; // price units; tweak if needed
            if (ema9 !== null && ema15 !== null) {
                const diff = ema9 - ema15;
                if (Math.abs(diff) >= emaDeadband) {
                    if (diff > 0) score += 2;
                    else if (diff < 0) score -= 2;
                    // confirmation vs a longer EMA if available (use deadband for transitive checks)
                    if (ema65 !== null) {
                        if (diff > 0 && (ema15 - ema65) > emaDeadband) score += 0.5;
                        if (diff < 0 && (ema65 - ema15) > emaDeadband) score -= 0.5;
                    }
                }
            }
            // DMA / long-term bias (timeframe-agnostic)
            // Prefer using all configured DMA columns (dma_10, dma_20, dma_50, dma_100, dma_200)
            // and split the previous +/-1.5 bias across them. If none are available,
            // fall back to cmp vs ema200 (legacy behaviour).
            try {
                const dmaKeys = Object.keys(colIndexMap || {}).filter(k => k.startsWith('dma_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
                if (dmaKeys.length > 0 && cmp !== null) {
                    const perWeight = 1.5 / dmaKeys.length;
                    let found = false;
                    for (const dk of dmaKeys) {
                        let dv = null;
                        // try to read from API object first
                        if (symbolData && typeof symbolData === 'object') dv = safeNum(symbolData[dk]);
                        // fallback to DOM cell when symbol string or API missing value
                        if ((dv === null || dv === undefined) && (typeof symbolData === 'string' || (symbolData && (symbolData.Symbol || symbolData.symbol)))) {
                            const sym = (typeof symbolData === 'string') ? symbolData : (symbolData.Symbol || symbolData.symbol);
                            const row = document.getElementById(`row-${sym}`);
                            if (row && colIndexMap[dk] !== undefined) {
                                const cell = row.querySelectorAll('td')[colIndexMap[dk]];
                                dv = parseNumericFromCell(cell, cmp);
                            }
                        }
                        if (dv !== null && dv !== undefined && !isNaN(dv)) {
                            found = true;
                            if (cmp > dv) score += perWeight; else if (cmp < dv) score -= perWeight;
                        }
                    }
                    // if no DMA values were found, fallback to ema200 if available
                    if (!found && cmp !== null && ema200 !== null) {
                        if (cmp > ema200) score += 1.5; else if (cmp < ema200) score -= 1.5;
                    }
                } else if (cmp !== null && ema200 !== null) {
                    if (cmp > ema200) score += 1.5; else if (cmp < ema200) score -= 1.5;
                }
            } catch (e) { /* ignore DMA parsing errors and fallback to ema200 below */ }
            // RSI contribution for the selected timeframe
            if (rsi_tf !== null) {
                if (rsi_tf >= 70) score += 1;
                else if (rsi_tf <= 30) score -= 1;
                else if (rsi_tf >= 55) score += 0.5;
                else if (rsi_tf <= 45) score -= 0.5;
            }
            return score;
        }

        // Ensure DMA values exist for visible rows by triggering a 'dma' refresh for rows missing DMA
        async function ensureDmaForVisibleRows() {
            try {
                const tbody = document.getElementById('symbolsTBody');
                if (!tbody) return;
                const dmaKeys = Object.keys(colIndexMap || {}).filter(k => k.startsWith('dma_'));
                if (dmaKeys.length === 0) return;
                const toRefresh = [];
                tbody.querySelectorAll('tr').forEach(tr => {
                    if (tr.style.display === 'none') return;
                    const cells = tr.querySelectorAll('td');
                    // if any dma cell is empty or contains '-' schedule refresh
                    const anyMissing = dmaKeys.some(k => {
                        const idx = colIndexMap[k];
                        const cell = cells[idx];
                        if (!cell) return true;
                        const txt = (cell.innerText || '').trim();
                        return txt === '' || txt === '-' || txt === '%' || txt.toLowerCase().includes('muted') || txt === '—' || txt === '–' || txt === '\u2014';
                    });
                    if (anyMissing) {
                        const sym = tr.id && tr.id.replace && tr.id.replace('row-','');
                        if (sym) toRefresh.push(sym);
                    }
                });
                if (toRefresh.length === 0) return;
                // Limit concurrency to avoid server overload
                await runWithConcurrency(toRefresh, async (sym) => { await refreshRow(sym, 'dma'); }, 4);
            } catch (e) { console.warn('ensureDmaForVisibleRows failed', e); }
        }

        // Map numeric score to labelled HTML used in table cells
        function scoreToLabelHtml(score) {
            if (score === null || score === undefined || isNaN(score)) return '<span class="reco-neutral">Neutral</span>';
            if (score >= 2.5) return '<span class="reco-bull">Strong Bull</span>';
            if (score >= 1.0) return '<span class="reco-bull">Bullish</span>';
            if (score <= -2.5) return '<span class="reco-bear">Strong Bear</span>';
            if (score <= -1.0) return '<span class="reco-bear">Bearish</span>';
            return '<span class="reco-neutral">Neutral</span>';
        }

        // Build a small tooltip string describing the breakdown of the reco for hover
        function buildRecoTooltip(symbolData, score) {
            try {
                const tfMin = getTimeframeMinutes();
                const rsiKey = `rsi_${tfMin}`;
                // attempt to extract contributing values (best-effort)
                let cmp = null, ema9 = null, ema15 = null, ema65 = null, ema200 = null, rsi_tf = null;
                try {
                    const s = (typeof symbolData === 'string') ? document.getElementById(`row-${symbolData}`) : null;
                    if (s && s.querySelector) {
                        const cells = s.querySelectorAll('td');
                        const read = (idx) => parseNumericFromCell(cells[idx], parseFloat(cells[1]?.getAttribute('data-cmp')||NaN));
                        cmp = read(colIndexMap['CMP'] || 1);
                        rsi_tf = read(colIndexMap[rsiKey] !== undefined ? colIndexMap[rsiKey] : 3);
                        ema9 = read(colIndexMap['ema_9'] !== undefined ? colIndexMap['ema_9'] : 6);
                        ema15 = read(colIndexMap['ema_15'] !== undefined ? colIndexMap['ema_15'] : 7);
                        ema65 = read(colIndexMap['ema_65'] !== undefined ? colIndexMap['ema_65'] : 8);
                        ema200 = read(colIndexMap['ema_200'] !== undefined ? colIndexMap['ema_200'] : 9);
                    } else if (symbolData && typeof symbolData === 'object') {
                        cmp = parseFloat(symbolData.CMP || symbolData.cmp || symbolData['CMP']);
                        ema9 = parseFloat(symbolData.ema_9);
                        ema15 = parseFloat(symbolData.ema_15);
                        ema65 = parseFloat(symbolData.ema_65) || parseFloat(symbolData.ema_21);
                        ema200 = parseFloat(symbolData.ema_200) || parseFloat(symbolData.dma_200);
                        rsi_tf = parseFloat(symbolData[rsiKey]);
                    }
                } catch (e) { /* ignore */ }

                const parts = [];
                if (!isNaN(ema9) && !isNaN(ema15)) parts.push(`EMA9 ${ema9.toFixed(2)} vs EMA15 ${ema15.toFixed(2)} (${ema9>ema15?'+2':'-2'})`);
                if (!isNaN(ema65) && !isNaN(ema9) && !isNaN(ema15)) {
                    const conf = (ema9>ema15 && ema15>ema65) ? '+0.5' : (ema9<ema15 && ema15<ema65 ? '-0.5' : '0');
                    const confLabel = (conf === '0') ? 'none' : conf;
                    parts.push(`EMA65 ${ema65.toFixed(2)} conf ${confLabel}`);
                }
                // Include DMA (short/med-term) values and their contribution in the breakdown if available
                try {
                    const dmaKeys = Object.keys(colIndexMap || {}).filter(k => k.startsWith('dma_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
                    if (dmaKeys.length > 0 && cmp !== null) {
                        const perWeight = 1.5 / dmaKeys.length;
                        const dmaParts = [];
                        const contribParts = [];
                        let foundAny = false;
                        for (const dk of dmaKeys) {
                            let v = NaN;
                            if (s && s.querySelector) {
                                const cells = s.querySelectorAll('td');
                                const idx = colIndexMap[dk];
                                if (idx !== undefined && cells[idx]) {
                                    v = parseNumericFromCell(cells[idx], parseFloat(cells[1]?.getAttribute('data-cmp')||NaN));
                                }
                            }
                            if ((v === null || v === undefined || isNaN(v)) && symbolData && typeof symbolData === 'object') {
                                v = parseFloat(symbolData[dk]);
                            }
                            if (!isNaN(v)) {
                                foundAny = true;
                                dmaParts.push(`${dk.toUpperCase().replace('_','')} ${v.toFixed(2)}`);
                                const cw = (cmp > v) ? `+${perWeight.toFixed(2)}` : (cmp < v ? `-${perWeight.toFixed(2)}` : '+0.00');
                                contribParts.push(`${dk.toUpperCase().replace('_','')}: ${cw}`);
                            }
                        }
                        if (dmaParts.length) parts.push(`DMA: ${dmaParts.join(' | ')}`);
                        if (contribParts.length) parts.push(`DMA contribs: ${contribParts.join(', ')}`);
                        // if none found, will still show CMP vs EMA200 later as fallback
                    }
                } catch(e) { /* ignore dma extraction failures */ }

                if (!isNaN(cmp) && !isNaN(ema200)) parts.push(`CMP ${cmp.toFixed(2)} vs EMA200 ${ema200.toFixed(2)} (${cmp>ema200?'+1.5':'-1.5'})`);
                if (!isNaN(rsi_tf)) parts.push(`RSI(${tfMin}) ${rsi_tf.toFixed(1)}`);
                const summary = parts.length ? parts.join(' \n') : 'Insufficient data to compute breakdown';
                return `Score: ${isNaN(score) ? 'N/A' : score.toFixed(2)}\n${summary}`;
            } catch (e) { return 'Reco breakdown unavailable'; }
        }

        function createTableRow(symbolData) {
            const tr = document.createElement('tr');
            const s = symbolData.Symbol || symbolData;
            tr.id = `row-${s}`;

            const getCellVal = (key) => symbolData[key] ?? '';
            const td = (html, cls='') => { const c = document.createElement('td'); if (cls) c.className = cls; c.innerHTML = html; return c; };
            const fmtNum = (v) => (v === null || v === undefined || v === '') ? '<span class="cell-muted">-</span>' : Number(v).toFixed(2);
            const colorRsiHtml = (v) => {
                if (v===null || v===undefined || v==='') return '<span class="cell-muted">-</span>';
                const n = Number(v); if (isNaN(n)) return '<span class="cell-muted">-</span>';
                // Per user: Red when >=70, Green when <=30, otherwise Grey
                if (n >= 70) return `<span class="rsi-neg">${n.toFixed(2)}</span>`;
                if (n <= 30) return `<span class="rsi-pos">${n.toFixed(2)}</span>`;
                return `<span class="rsi-neutral">${n.toFixed(2)}</span>`;
            };
            const colorCompareHtml = (val, cmp) => {
                // For EMA/DMA: Green if CMP > indicator, Red if CMP < indicator, Grey if equal or unavailable
                if (val===null || val===undefined || val==='') return '<span class="cell-muted">-</span>';
                const n = Number(val); const c = Number(cmp);
                if (isNaN(n)) return '<span class="cell-muted">-</span>';
                if (isNaN(c)) return `<span class="percent-neutral">${n.toFixed(2)}</span>`;
                if (c > n) return `<span class="percent-pos">${n.toFixed(2)}</span>`; // CMP > indicator -> green
                if (c < n) return `<span class="percent-neg">${n.toFixed(2)}</span>`; // CMP < indicator -> red
                return `<span class="percent-neutral">${n.toFixed(2)}</span>`;
            };
            const pct = (val, cmp) => {
                // val = indicator, cmp = CMP
                if (val==null || val==='' || cmp==null || cmp==='' ) return '<span class="cell-muted">-</span>';
                const n = Number(val), c = Number(cmp);
                if (isNaN(n) || isNaN(c) || c===0) return '<span class="cell-muted">-</span>';
                const d = ((n - c)/c)*100;
                // Color GREEN when CMP > indicator (bullish), RED when CMP < indicator (bearish), GREY when equal
                let cls = 'percent-neutral';
                if (c > n) cls = 'percent-pos';
                else if (c < n) cls = 'percent-neg';
                return `<span class="${cls}" data-pct="${d}">${d.toFixed(2)}%</span>`;
            };
            const reco = () => {
                try {
                    // Use the unified, timeframe-aware scorer
                    const sc = computeRecoScore(symbolData);
                    return scoreToLabelHtml(sc);
                } catch (e) { return '<span class="reco-neutral">Neutral</span>'; }
            };

            // Symbol cell: chart icon directly left of symbol name
            tr.appendChild(td(`<button class="btn-icon" title="Open Chart" onclick="openChartModal('${s}')" style="margin-right:8px"><i class="fas fa-chart-line"></i></button><span style="vertical-align:middle"><strong>${s}</strong></span>`, 'symbol-col'));
            // CMP cell: render raw text but store a numeric data-cmp attribute for later comparisons
            const rawCmp = getCellVal('CMP');
            const cmpNum = (rawCmp === null || rawCmp === undefined || rawCmp === '') ? NaN : parseFloat(String(rawCmp).replace(/[^0-9.\-]/g,''));
            const cmpCell = document.createElement('td');
            cmpCell.innerHTML = rawCmp ? rawCmp : '<span class="cell-muted">-</span>';
            if (!isNaN(cmpNum)) cmpCell.setAttribute('data-cmp', String(cmpNum));
            tr.appendChild(cmpCell);
            // create reco cell: show placeholder until indicators are computed and rendered
            // Default to a neutral placeholder ('-') while marking as pending so
            // recomputation/update can still run asynchronously. This avoids
            // showing a spinner by default but keeps the row eligible for updates.
            const recoTd = td('<span class="reco-neutral">-</span>', 'reco-cell');
            // mark as pending so other code can opt-in to updating when ready
            recoTd.setAttribute('data-reco-state', 'pending');
            tr.appendChild(recoTd);
            // Mini 'Trend' candles canvas cell (placed here so it lines up with the 'Trend' header)
            const miniTd = document.createElement('td');
            miniTd.style.width = '80px';
            miniTd.style.textAlign = 'center';
            miniTd.innerHTML = `<canvas id="mini-${s}" width="80" height="20" style="width:80px;height:20px"></canvas>`;
            tr.appendChild(miniTd);
            // Render RSI columns dynamically if present in colIndexMap
            const rsiKeys = Object.keys(colIndexMap).filter(k => k.startsWith('rsi_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
            rsiKeys.forEach(k => tr.appendChild(td(colorRsiHtml(getCellVal(k)))));
            // Use numeric CMP when available (clean any currency/formatting). Pass numeric CMP into helpers
            const cmpVal = !isNaN(cmpNum) ? cmpNum : NaN;
            // Render EMA columns dynamically
            const emaKeys = Object.keys(colIndexMap).filter(k => k.startsWith('ema_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
            // Special rendering: EMA-9 and EMA-15 should share color based on their relation.
            const parseNumForCell = (v) => { if (v === null || v === undefined || v === '') return NaN; const s = String(v).replace(/[^0-9.\-]/g,''); const n = parseFloat(s); return isNaN(n) ? NaN : n; };
            const ema9Raw = getCellVal('ema_9'); const ema15Raw = getCellVal('ema_15');
            const ema9Num = parseNumForCell(ema9Raw); const ema15Num = parseNumForCell(ema15Raw);
            emaKeys.forEach(k => {
                try {
                    const val = getCellVal(k);
                    if (k === 'ema_9' || k === 'ema_15') {
                        // Determine color from ema9 vs ema15
                        let cls = 'percent-neutral';
                        if (!isNaN(ema9Num) && !isNaN(ema15Num)) {
                            if (ema9Num > ema15Num) cls = 'percent-pos';
                            else if (ema9Num < ema15Num) cls = 'percent-neg';
                            else cls = 'percent-neutral';
                        }
                        // Content: show percent if toggle on, else numeric
                        let content = '';
                        if (showPctDiff) {
                            if (val === null || val === undefined || val === '' || isNaN(parseNumForCell(val)) || isNaN(cmpVal) || cmpVal === 0) {
                                content = '<span class="cell-muted">-</span>';
                            } else {
                                const n = parseNumForCell(val);
                                const d = ((n - cmpVal) / cmpVal) * 100;
                                content = `${d.toFixed(2)}%`;
                            }
                        } else {
                            content = (val === null || val === undefined || val === '') ? '<span class="cell-muted">-</span>' : Number(parseNumForCell(val)).toFixed(2);
                        }
                        tr.appendChild(td(`<span class="${cls}">${content}</span>`));
                    } else {
                        tr.appendChild(td(showPctDiff ? pct(getCellVal(k), cmpVal) : colorCompareHtml(getCellVal(k), cmpVal)));
                    }
                } catch (e) { tr.appendChild(td('<span class="cell-muted">-</span>')); }
            });
            // Render DMA columns dynamically
            const dmaKeys = Object.keys(colIndexMap).filter(k => k.startsWith('dma_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
            dmaKeys.forEach(k => tr.appendChild(td(showPctDiff ? pct(getCellVal(k), cmpVal) : colorCompareHtml(getCellVal(k), cmpVal))));
            // LastUpdate column removed to match legacy compact table

            // Actions with per-scanner controls and status badges (reuse chip/time ids)
            // Show per-scanner chips so updateScannerChip can update loader icon and execution duration.
            // Keep the compact 'All' chip and popup for additional actions.
            const actionsHtml = `
                <span id="chip-${s}-all" class="action-chip status-idle" title="Run All" onclick="retryAllScannersForSymbol('${s}')">All</span>
                <i class="fas fa-ellipsis-h popup-icon" title="More" onclick="toggleActionPopup(event, '${s}')"></i>
                <div id="action-popup-${s}" class="action-popup" style="display:none;">
                    <div style="display:flex; gap:6px; margin-bottom:6px;">
                        <div style="display:flex; flex-direction:column; align-items:center;">
                            <span id="chip-${s}-rsi" class="action-chip status-idle" title="Run RSI" onclick="runScanner('${s}','rsi')">R</span>
                            <span id="last-${s}-rsi" class="last-update"><span>-</span></span>
                        </div>
                        <div style="display:flex; flex-direction:column; align-items:center;">
                            <span id="chip-${s}-ema" class="action-chip status-idle" title="Run EMA" onclick="runScanner('${s}','ema')">E</span>
                            <span id="last-${s}-ema" class="last-update"><span>-</span></span>
                        </div>
                        <div style="display:flex; flex-direction:column; align-items:center;">
                            <span id="chip-${s}-dma" class="action-chip status-idle" title="Run DMA" onclick="runScanner('${s}','dma')">D</span>
                            <span id="last-${s}-dma" class="last-update"><span>-</span></span>
                        </div>
                    </div>
                </div>
            `;
            const actionsCell = td(actionsHtml);
            actionsCell.style.position = 'relative';
            tr.appendChild(actionsCell);


            // If the symbolData lacks some newer fields (rsi_5, ema_21, dma_100/dma_200),
            // request per-symbol analysis to populate them. This handles cases where
            // /api/symbol-table doesn't include those keys yet.
            (function(symbolObj, rowId){
                const has = (k) => symbolObj && symbolObj[k] !== undefined && symbolObj[k] !== null && symbolObj[k] !== '';
                // Determine required keys dynamically from colIndexMap
                const requiredRsi = Object.keys(colIndexMap).filter(k=>k.startsWith('rsi_'));
                const requiredEma = Object.keys(colIndexMap).filter(k=>k.startsWith('ema_'));
                const requiredDma = Object.keys(colIndexMap).filter(k=>k.startsWith('dma_'));
                const needsRsi = requiredRsi.some(k => !has(k));
                const needsEma = requiredEma.some(k => !has(k));
                const needsDma = requiredDma.some(k => !has(k));
                if (needsRsi || needsEma || needsDma) {
                    // small stagger to avoid bursting requests on large symbol lists
                    setTimeout(() => {
                        try {
                            if (needsRsi) refreshRow(rowId, 'rsi');
                            if (needsEma) refreshRow(rowId, 'ema');
                            if (needsDma) refreshRow(rowId, 'dma');
                        } catch(e) { /* ignore */ }
                    }, 200);
                            // Register mini canvas for lazy loading (IntersectionObserver)
                            try { observeMiniCanvas(s); } catch(e) { /* ignore */ }
                }
            })(symbolData, s);

            return tr;
        }

        function compareByKey(a, b, key, dir) {
            // Special-case Reco: compute numeric score for sorting to ensure proper ordering
            if (key === 'Reco') {
                const sa = computeRecoScore(a);
                const sb = computeRecoScore(b);
                const cmpScore = (sa || 0) - (sb || 0);
                return dir === 'asc' ? cmpScore : -cmpScore;
            }
            const av = (a[key] !== undefined ? a[key] : (key==='CMP' ? a.CMP : (key==='Symbol' ? a.Symbol : undefined)));
            const bv = (b[key] !== undefined ? b[key] : (key==='CMP' ? b.CMP : (key==='Symbol' ? b.Symbol : undefined)));
            const toNum = (v) => {
                if (v === null || v === undefined) return NaN;
                if (typeof v === 'number') return v;
                const s = String(v).replace(/[^0-9.\-]/g, '');
                const n = parseFloat(s);
                return isNaN(n) ? NaN : n;
            };
            let cmp = 0;
            if (key === 'Symbol' || (isNaN(toNum(av)) && isNaN(toNum(bv)))) {
                cmp = String(av || '').localeCompare(String(bv || ''));
            } else {
                cmp = (toNum(av) || 0) - (toNum(bv) || 0);
            }
            return dir === 'asc' ? cmp : -cmp;
        }

        function applyFilter(term) {
            term = term.toUpperCase();
            const tbody = document.getElementById('symbolsTBody');
            tbody.querySelectorAll('tr').forEach(tr => {
                const sym = tr.id.replace('row-','');
                tr.style.display = sym.toUpperCase().includes(term) ? '' : 'none';
            });
        }

        // New: apply advanced filters (Reco checkboxes + EMA/DMA percent ranges)
        function applyFilters() {
            const min = parseFloat(document.getElementById('filter_pct_min')?.value || NaN);
            const max = parseFloat(document.getElementById('filter_pct_max')?.value || NaN);
            const useEma = document.getElementById('filter_apply_ema')?.checked ?? true;
            const useDma = document.getElementById('filter_apply_dma')?.checked ?? true;
            // Determine Reco visibility settings: prefer dynamic panel filters if present
            let showDash = true, showBull = true, showNeutral = true, showBear = true;
            const panelContainer = document.getElementById('panelRecoFilters');
            if (panelContainer && panelContainer.querySelectorAll('input[type=checkbox]').length > 0) {
                // Read simplified 3-category panel checkboxes (Bull / Neutral / Bear)
                const dashCb = document.getElementById('panel_reco_dash');
                const bullCb = document.getElementById('panel_reco_bull');
                const neutralCb = document.getElementById('panel_reco_neutral');
                const bearCb = document.getElementById('panel_reco_bear');
                showDash = !!(dashCb && dashCb.checked);
                showBull = !!(bullCb && bullCb.checked);
                showNeutral = !!(neutralCb && neutralCb.checked);
                showBear = !!(bearCb && bearCb.checked);
            } else {
                showDash = document.getElementById('filter_dash')?.checked ?? true;
                showBull = document.getElementById('filter_bull')?.checked ?? true;
                showNeutral = document.getElementById('filter_neutral')?.checked ?? true;
                showBear = document.getElementById('filter_bear')?.checked ?? true;
            }

            const tbody = document.getElementById('symbolsTBody');
            tbody.querySelectorAll('tr').forEach(tr => {
                let visible = true;
                // Reco check
                const recoCell = tr.querySelector('.reco-cell');
                if (recoCell) {
                    const txt = (recoCell.innerText || '').trim();
                    // Normalize typical dash characters to '-'
                    const normalized = txt.replace(/[\u2012\u2013\u2014\u2212]/g, '-');
                    if (normalized === '-' || normalized === '\u2014' || normalized.length === 0) {
                        if (!showDash) visible = false;
                    } else if (normalized.includes('Strong Bull') || normalized.includes('Bullish')) {
                        if (!showBull) visible = false;
                    } else if (normalized.includes('Strong Bear') || normalized.includes('Bearish')) {
                        if (!showBear) visible = false;
                    } else {
                        if (!showNeutral) visible = false;
                    }
                }

                // EMA/DMA percent range check: compute percent using either data-pct
                // (when rendered in pct mode) or by computing ((indicator - CMP)/CMP)*100
                if (visible && (useEma || useDma) && document.getElementById('togglePct')?.checked) {
                    const cols = tr.querySelectorAll('td');
                    // Determine EMA/DMA column indices from colIndexMap
                    const emaKeys = Object.keys(colIndexMap || {}).filter(k => k.startsWith('ema_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
                    const dmaKeys = Object.keys(colIndexMap || {}).filter(k => k.startsWith('dma_')).sort((a,b)=>parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]));
                    const checkKeys = [];
                    if (useEma) checkKeys.push(...emaKeys);
                    if (useDma) checkKeys.push(...dmaKeys);

                    // Get CMP for this row
                    const cmpCell = cols[1];
                    let cmp = NaN;
                    try {
                        const attr = cmpCell && cmpCell.getAttribute ? cmpCell.getAttribute('data-cmp') : null;
                        cmp = (attr !== null && attr !== undefined) ? parseFloat(attr) : parseFloat((cmpCell && (cmpCell.innerText||'')).replace(/[^0-9.\-]/g,''));
                    } catch(e) { cmp = NaN; }

                    let inRange = true;
                    for (const key of checkKeys) {
                        const idx = colIndexMap[key];
                        if (idx === undefined) continue;
                        const cell = cols[idx];
                        if (!cell) continue;

                        // Prefer explicit data-pct attribute
                        let pct = NaN;
                        try {
                            const pctEl = cell.querySelector && cell.querySelector('[data-pct]');
                            if (pctEl) {
                                pct = parseFloat(pctEl.getAttribute('data-pct'));
                            } else {
                                // Try data-original attribute (absolute indicator value)
                                const orig = cell.getAttribute && cell.getAttribute('data-original');
                                let indicator = NaN;
                                if (orig !== null && orig !== undefined && orig !== '') {
                                    indicator = parseFloat(orig);
                                } else {
                                    // Fallback: parse visible text (strip % and non-numeric)
                                    const txt = (cell.innerText || '').replace('%','').replace(/[^0-9.\-]/g,'').trim();
                                    if (txt !== '') indicator = parseFloat(txt);
                                }
                                if (!isNaN(indicator) && !isNaN(cmp) && cmp !== 0) {
                                    pct = ((indicator - cmp) / cmp) * 100;
                                }
                            }
                        } catch(e) { pct = NaN; }

                        // If pct couldn't be determined, treat as out-of-range (hide)
                        if (isNaN(pct)) { inRange = false; break; }
                        if (!isNaN(min) && pct < min) { inRange = false; break; }
                        if (!isNaN(max) && pct > max) { inRange = false; break; }
                    }
                    if (!inRange) visible = false;
                }

                tr.style.display = visible ? '' : 'none';
            });
        }

        // Toggle/show the per-row action popup (R/E/D/All)
        function toggleActionPopup(evt, symbol) {
            try {
                evt = evt || window.event;
                evt.stopPropagation();
                const popup = document.getElementById(`action-popup-${symbol}`);
                if (!popup) return;
                // position popup near the icon, but avoid overflowing the parent's right edge (scrollbar area)
                const icon = evt.currentTarget || evt.target;
                const rect = icon.getBoundingClientRect();
                const parentRect = icon.parentElement.getBoundingClientRect();
                const isHidden = !popup || popup.style.display === 'none' || popup.style.display === '';
                if (isHidden) {
                    // show it hidden to measure size
                    popup.style.display = 'flex';
                    popup.style.visibility = 'hidden';
                    // measure
                    const popupWidth = popup.offsetWidth || 120;
                    const popupHeight = popup.offsetHeight || 28;
                    // prefer left = -110 (place popup to left of icon), but clamp so popup stays inside the parent
                    // Using negative left moves the popup to the left of the icon (into the cell area);
                    // clamp between minLeft (prevent too far-left) and maxLeft (prevent overflow to right)
                    const preferredLeft = -110;
                    const maxLeft = Math.max(0, parentRect.width - popupWidth - 8); // right-most allowed inside parent
                    const minLeft = Math.min(0, -popupWidth + 8); // left-most allowed so popup doesn't fully disappear
                    let left = preferredLeft;
                    if (left > maxLeft) left = maxLeft;
                    if (left < minLeft) left = minLeft;
                    const top = (rect.bottom - parentRect.top + 6);
                    popup.style.left = left + 'px';
                    popup.style.top = top + 'px';
                    popup.style.visibility = 'visible';
                } else {
                    popup.style.display = 'none';
                }
            } catch (e) { console.warn('toggleActionPopup', e); }
        }

        function hideActionPopup(symbol) {
            try {
                const popup = document.getElementById(`action-popup-${symbol}`);
                if (popup) popup.style.display = 'none';
            } catch (e) {}
        }

        // Close any open action popups when clicking elsewhere
        document.addEventListener('click', function(e) {
            try {
                const openPopups = document.querySelectorAll('.action-popup');
                openPopups.forEach(p => { if (p.style.display !== 'none') p.style.display = 'none'; });
            } catch (e) {}
        });

        // Update scanner chip status (display time inside chip; running shows blink)
        function updateScannerChip(symbol, scanner, status, time = null, error = null) {
            const chip = document.getElementById(`chip-${symbol}-${scanner}`);
            if (!chip) return;

            // Normalize scanner key for state object (some callers may pass 'all')
            if (!scannerStates[symbol]) scannerStates[symbol] = { rsi:{}, ema:{}, dma:{} };
            if (!scannerStates[symbol][scanner]) scannerStates[symbol][scanner] = { status: 'idle', time: null };

            // Update internal state
            scannerStates[symbol][scanner].status = status;
            scannerStates[symbol][scanner].time = time;

            // Map short label
            const labelMap = { rsi: 'R', ema: 'E', dma: 'D', all: 'All' };
            const baseLabel = labelMap[scanner] || (scanner.toUpperCase ? scanner.toUpperCase() : String(scanner));

            // Build chip content
            if (status === 'running') {
                chip.innerHTML = `${baseLabel} <i class="fas fa-spinner fa-spin" style="margin-left:6px;font-size:0.85em"></i>`;
            } else if (status === 'success' && time !== null) {
                chip.innerHTML = `${baseLabel} <span style="font-size:0.78em; opacity:0.9; margin-left:6px">(${time}s)</span>`;
            } else if (status === 'error') {
                chip.innerHTML = `${baseLabel} <i class="fas fa-exclamation-triangle" style="margin-left:6px;color:#ef4444"></i>`;
            } else {
                chip.textContent = baseLabel;
            }

            // Set classes: keep action-chip base, add running animation and status styling
            const runningClass = status === 'running' ? 'chip-running' : '';
            chip.className = `action-chip ${runningClass} status-${status}`.trim();

            // Tooltip for errors
            if (status === 'error' && error) {
                chip.title = `Error: ${error}`;
            } else {
                chip.title = `${scanner.toUpperCase()} - ${status}`;
            }

            // Update internal scannerStates object if present and trigger a Reco/UI refresh
            try {
                if (!scannerStates[symbol]) scannerStates[symbol] = { rsi:{}, ema:{}, dma:{} };
                if (scannerStates[symbol][scanner]) {
                    scannerStates[symbol][scanner].status = status;
                    scannerStates[symbol][scanner].time = time;
                }
            } catch(e) { /* ignore */ }

            // Update per-scanner UI state for the popup timestamps, but do not
            // set success timestamp here — prefer the server-provided last-record
            // timestamp (written by refreshRow or runScanner) so it reflects actual
            // data time rather than the local now().
            try {
                const tsSpan = document.getElementById(`last-${symbol}-${scanner}`);
                if (tsSpan) {
                    if (status === 'running') {
                        tsSpan.innerHTML = `<span>running...</span>`;
                    } else if (status === 'error') {
                        tsSpan.innerHTML = `<span style="color:#ef4444">error</span>`;
                    } else if (status === 'idle') {
                        // leave previous timestamp if present; otherwise show '-'
                        if (!tsSpan.innerText || tsSpan.innerText.trim() === '') tsSpan.innerHTML = `<span>-</span>`;
                    }
                }
            } catch(e) { /* ignore */ }

            // After state change, attempt to refresh the Reco UI for this row so spinner/label updates
            try { updateRecoForRow(symbol); } catch(e) { /* ignore */ }
        }

        // Run individual scanner
        async function runScanner(symbol, scanner) {
            const scanKey = `${symbol}-${scanner}`;
            
            if (runningScans.has(scanKey)) {
                toastr.warning(`${scanner.toUpperCase()} scanner already running for ${symbol}`, 'Already Running');
                return;
            }
            
            try {
                runningScans.add(scanKey);
                totalRunning++;
                updateScannerChip(symbol, scanner, 'running');
                updateProgress();
                
                toastr.info(`Starting ${scanner.toUpperCase()} analysis for ${symbol}`, 'Scanner Started');
                
                const startTime = Date.now();
                
                const response = await fetch('/api/run-single-scanner', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        scanner: scanner,
                        symbol: symbol,
                        baseTimeframe: document.getElementById('timeframeSelect').value,
                        daysToList: 4
                    })
                });
                
                const result = await response.json();
                const executionTime = ((Date.now() - startTime) / 1000).toFixed(1);
                
                if (!response.ok || result.error) {
                    throw new Error(result.error || 'Scanner execution failed');
                }
                
                if (result.returncode === 0) {
                    updateScannerChip(symbol, scanner, 'success', executionTime);
                    toastr.success(`${scanner.toUpperCase()} completed for ${symbol} in ${executionTime}s`, 'Success');
                    // Best-effort: if the scanner run returned an immediate CMP/last price
                    // include it into the row so CMP is visible without a page refresh.
                    try {
                        const possibleCmpKeys = ['CMP','cmp','last','price','close','close_price'];
                        let cmpFromResult = NaN;
                        if (result) {
                            for (const k of possibleCmpKeys) {
                                if (result[k] !== undefined && result[k] !== null) { cmpFromResult = Number(result[k]); break; }
                                if (result.data && result.data[k] !== undefined && result.data[k] !== null) { cmpFromResult = Number(result.data[k]); break; }
                                if (result.payload && result.payload[k] !== undefined && result.payload[k] !== null) { cmpFromResult = Number(result.payload[k]); break; }
                            }
                        }
                        if (isFinite(cmpFromResult) && cmpFromResult !== 0) {
                            const row = document.getElementById(`row-${symbol}`);
                            if (row) {
                                const cells = row.querySelectorAll('td');
                                const cmpCell = cells[1];
                                if (cmpCell) {
                                    cmpCell.innerHTML = Number(cmpFromResult).toFixed(2);
                                    cmpCell.setAttribute('data-cmp', String(cmpFromResult));
                                }
                                // Also refresh mini candle immediately
                                try { observeMiniCanvas(symbol); loadMiniSpark(symbol).catch(()=>{}); } catch(e) {}
                            }
                        }
                        // If the run result contains a timestamp for the latest record, show it
                        try {
                            const ts = extractTimestampFromResult(result);
                            if (ts) {
                                const row = document.getElementById(`row-${symbol}`);
                                if (row) {
                                    ['rsi','ema','dma'].forEach(sc => {
                                        const el = document.getElementById(`last-${symbol}-${sc}`);
                                        if (el) el.innerHTML = `<span>${ts.toLocaleString()}</span>`;
                                    });
                                }
                            }
                        } catch(e) { /* ignore */ }
                        // Also check for RSI-60-like values in the run result and update that cell immediately
                        try {
                            const rsiCandidates = [];
                            const srcs = [result, result.data, result.payload];
                            const rsiRegex = /rsi[_-]?(60|1h|60m|min|mins)?$/i;
                            for (const src of srcs) {
                                if (!src || typeof src !== 'object') continue;
                                for (const k of Object.keys(src)) {
                                    if (rsiRegex.test(k)) {
                                        const val = Number(src[k]);
                                        if (!isNaN(val)) rsiCandidates.push({ key: k, val });
                                    }
                                }
                            }
                            if (rsiCandidates.length > 0) {
                                const row = document.getElementById(`row-${symbol}`);
                                if (row) {
                                    const cells = row.querySelectorAll('td');
                                    // Prefer exact 'rsi_60' in colIndexMap if present, else use the first candidate
                                    const preferredKey = (colIndexMap && colIndexMap['rsi_60'] !== undefined) ? 'rsi_60' : rsiCandidates[0].key;
                                    const colKey = Object.keys(colIndexMap || {}).find(k => k.toLowerCase() === preferredKey.toLowerCase()) || preferredKey;
                                    const idx = colIndexMap && colIndexMap[colKey];
                                    const rsiVal = rsiCandidates[0].val;
                                    if (idx !== undefined && cells[idx]) {
                                        // Colorize like other RSI cells
                                        const n = Number(rsiVal);
                                        let out = '<span class="cell-muted">-</span>';
                                        if (!isNaN(n)) {
                                            if (n >= 70) out = `<span class="rsi-neg">${n.toFixed(2)}</span>`;
                                            else if (n <= 30) out = `<span class="rsi-pos">${n.toFixed(2)}</span>`;
                                            else out = `<span class="rsi-neutral">${n.toFixed(2)}</span>`;
                                        }
                                        cells[idx].innerHTML = out;
                                    }
                                }
                            }
                        } catch(e) { /* ignore RSI immediate update errors */ }
                    } catch(e) { /* ignore */ }
                    await refreshRow(symbol, scanner);
                } else {
                    throw new Error(result.error || `Scanner returned code ${result.returncode}`);
                }
                
            } catch (error) {
                console.error(`Scanner error for ${symbol}-${scanner}:`, error);
                updateScannerChip(symbol, scanner, 'error', null, error.message);
                toastr.error(`${scanner.toUpperCase()} failed for ${symbol}: ${error.message}`, 'Error');
                
            } finally {
                runningScans.delete(scanKey);
                totalRunning--;
                updateProgress();
            }
        }

        // Run all scanners for a symbol
        async function retryAllScannersForSymbol(symbol) {
            const scanners = ['rsi', 'ema', 'dma'];
            
            toastr.info(`Running all scanners for ${symbol}...`, 'Batch Analysis');
            
            for (const scanner of scanners) {
                await runScanner(symbol, scanner);
                // Small delay between scanners
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        // Run all for a specific scanner type
        async function runAllOfScanner(scanner) {
            const list = symbols.map(s => s.Symbol || s);
            let completed = 0;
            totalRunning = 0;
            updateProgress();
            stopRequestedFor[scanner] = false;
            for (const sym of list) {
                await runScanner(sym, scanner);
                completed++;
                updateStatusBar(`${scanner.toUpperCase()} progress: ${completed}/${list.length}`);
                if (stopRequested || stopRequestedFor[scanner]) break;
                await new Promise(r => setTimeout(r, 150));
            }
            updateStatusBar('Ready');
        }

        // Run all scanners for all symbols
        async function runAllScanners() {
            const runBtn = document.getElementById('runAllBtn');
            const stopBtn = document.getElementById('stopAllBtn');
            stopRequested = false;
            if (runBtn) runBtn.disabled = true;
            if (stopBtn) stopBtn.disabled = false;
            
            toastr.info(`Starting batch analysis for ${symbols.length} symbols...`, 'Batch Analysis');
            
            const scanners = ['rsi', 'ema', 'dma'];
            let completed = 0;
            const total = symbols.length * scanners.length;
            
            try {
                for (const symbol of symbols) {
                    if (stopRequested) break;
                    const symbolName = symbol.Symbol || symbol;
                    for (const scanner of scanners) {
                        if (stopRequested) break;
                        try {
                            await runScanner(symbolName, scanner);
                        } catch (err) {
                            // Keep going to next scan even if one fails
                            console.error(`Batch scan error for ${symbolName}-${scanner}:`, err);
                        }
                        completed++;
                        updateStatusBar(`Progress: ${completed}/${total} (${((completed/total)*100).toFixed(1)}%)`);
                        // Small delay to prevent overwhelming the server
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                }
                if (!stopRequested) {
                    toastr.success('Batch analysis completed!', 'Success');
                } else {
                    toastr.warning('Batch analysis stopped by user', 'Stopped');
                }
            } catch (error) {
                toastr.error('Batch analysis interrupted: ' + (error?.message || error), 'Error');
            } finally {
                if (runBtn) runBtn.disabled = false;
                if (stopBtn) stopBtn.disabled = true;
                updateStatusBar('Batch analysis finished');
            }
        }

        // Stop all running scanners
        function stopAllScanners() {
            stopRequested = true;
            // Existing scans will complete; prevent new ones
            toastr.info('Stopping after current scans finish...', 'Stopping');
        }

        // Setup event listeners
        function setupEventListeners() {
            // Guard each element lookup so missing/renamed nodes don't throw errors
            const elRunAll = document.getElementById('runAllBtn'); if (elRunAll) elRunAll.onclick = runAllScanners;
            const elStopAll = document.getElementById('stopAllBtn'); if (elStopAll) elStopAll.onclick = stopAllScanners;
            const elRefresh = document.getElementById('refreshSymbolsBtn'); if (elRefresh) elRefresh.onclick = () => location.reload();

            // Toggle-run/stop buttons for per-scanner batches
            const elRunRSIAll = document.getElementById('runRSIAllBtn'); if (elRunRSIAll) elRunRSIAll.onclick = async function() { const btn = this; if (!btn._running) { btn._running = true; btn.disabled = true; btn.innerHTML = '<i class="fas fa-stop"></i> Stop RSI'; stopRequestedFor.rsi = false; btn.disabled = false; await runAllOfScanner('rsi'); btn._running = false; btn.innerHTML = '<i class="fas fa-wave-square"></i> Run RSI All'; } else { stopRequestedFor.rsi = true; } };
            const elRunEMAAll = document.getElementById('runEMAAllBtn'); if (elRunEMAAll) elRunEMAAll.onclick = async function() { const btn = this; if (!btn._running) { btn._running = true; btn.disabled = true; btn.innerHTML = '<i class="fas fa-stop"></i> Stop EMA'; stopRequestedFor.ema = false; btn.disabled = false; await runAllOfScanner('ema'); btn._running = false; btn.innerHTML = '<i class="fas fa-chart-line"></i> Run EMA All'; } else { stopRequestedFor.ema = true; } };
            const elRunDMAAll = document.getElementById('runDMAAllBtn'); if (elRunDMAAll) elRunDMAAll.onclick = async function() { const btn = this; if (!btn._running) { btn._running = true; btn.disabled = true; btn.innerHTML = '<i class="fas fa-stop"></i> Stop DMA'; stopRequestedFor.dma = false; btn.disabled = false; await runAllOfScanner('dma'); btn._running = false; btn.innerHTML = '<i class="fas fa-chart-bar"></i> Run DMA All'; } else { stopRequestedFor.dma = true; } };

            // Logs and modals
            const elViewLogs = document.getElementById('viewLogsBtn') || document.getElementById('viewLogsBtnTop'); if (elViewLogs) elViewLogs.onclick = openLogModal;
            const elCloseLogModal = document.getElementById('closeLogModal'); if (elCloseLogModal) elCloseLogModal.onclick = closeLogModal;
            const elClearLogs = document.getElementById('clearLogsBtn'); if (elClearLogs) elClearLogs.onclick = clearLogs;
            const elRefreshLogs = document.getElementById('refreshLogsBtn'); if (elRefreshLogs) elRefreshLogs.onclick = loadLogs;

            // Theme toggle (old id or new top-row id)
            const elDarkToggle = document.getElementById('darkModeToggle') || document.getElementById('darkModeToggleTop');
            if (elDarkToggle) {
                try {
                    // Remove any inline onclick handler
                    elDarkToggle.onclick = null;
                    // Clone the node to strip any previously attached event listeners (addEventListener)
                    const cloned = elDarkToggle.cloneNode(true);
                    elDarkToggle.parentNode.replaceChild(cloned, elDarkToggle);
                    cloned.addEventListener('click', function (e) { e.preventDefault(); toggleDarkMode(); });
                } catch (e) {
                    // Fallback: set onclick if cloning fails
                    elDarkToggle.onclick = toggleDarkMode;
                }
            }
        }

        async function refreshRow(symbol, scanner) {
            try {
                const res = await fetch(`/api/symbol-analysis/${scanner}/${symbol}`);
                const data = await res.json();
                if (!data || data.error || !data.data) return;
                const row = document.getElementById(`row-${symbol}`);
                if (!row) return;
                const d = data.data;
                // Update columns we know (new layout includes rsi_5, ema_21, dma_100, dma_200)
                const map = {
                    'rsi': ['rsi_5','rsi_15','rsi_30'],
                    'ema': ['ema_9','ema_15','ema_21'],
                    'dma': ['dma_10','dma_20','dma_50','dma_100','dma_200']
                };
                const fmt = (v) => (v===null||v===undefined||v==='')?'-':Number(v).toFixed(2);
                const cells = row.querySelectorAll('td');
                // Use dynamic colIndexMap built by header builder
                const colIndex = colIndexMap || {};
                // --- Safe CMP update: update CMP immediately if payload provides a valid non-zero value.
                try {
                    const possibleCmpKeys = ['CMP','cmp','Cmp','last','Last'];
                    let cmpFromPayload = NaN;
                    for (const k of possibleCmpKeys) {
                        if (d && d[k] !== undefined && d[k] !== null) {
                            const n = Number(d[k]);
                            if (!isNaN(n)) { cmpFromPayload = n; break; }
                        }
                    }
                    // Apply only when payload CMP is a finite non-zero number to avoid accidental 0.00 overwrites
                    if (isFinite(cmpFromPayload) && cmpFromPayload !== 0) {
                        const cmpCell = cells[1];
                        if (cmpCell) {
                            cmpCell.innerHTML = Number(cmpFromPayload).toFixed(2);
                            cmpCell.setAttribute('data-cmp', String(cmpFromPayload));
                        }
                    }
                } catch(e) { /* ignore cmp write errors */ }
                for (const key of map[scanner]) {
                    // accept alternate key names returned by older APIs
                    const alternates = [key];
                    if (key === 'rsi_5') alternates.push('rsi_15','rsi_30');
                    if (key === 'ema_21') alternates.push('ema_65');
                    if (key === 'dma_100') alternates.push('dma_50');
                    if (key === 'dma_200') alternates.push('ema_200','dma_50');
                    // find first available data key in payload
                    let dataKey = alternates.find(k => (k in d && d[k] !== undefined && d[k] !== null));
                    if (!dataKey) dataKey = (key in d) ? key : null;
                    if (dataKey && colIndex && colIndex[key] !== undefined) {
                        if (showPctDiff && (key.startsWith('ema_') || key.startsWith('dma_'))) {
                            // Prefer numeric CMP stored on the cell via data-cmp
                            const cmpAttr = cells[1]?.getAttribute && cells[1].getAttribute('data-cmp');
                            const cmpVal = (cmpAttr !== null && cmpAttr !== undefined) ? parseFloat(cmpAttr) : parseFloat(cells[1]?.innerText?.replace(/[^0-9.\-]/g,'') || 'NaN');
                            if (!isNaN(cmpVal) && cmpVal !== 0) {
                                const n = parseFloat(d[dataKey]);
                                    if (!isNaN(n)) {
                                        const delta = ((n - cmpVal)/cmpVal)*100;
                                        // CMP > indicator -> bullish (green). CMP < indicator -> bearish (red). Equal -> neutral
                                        let pctClass = 'percent-neutral';
                                        if (cmpVal > n) pctClass = 'percent-pos';
                                        else if (cmpVal < n) pctClass = 'percent-neg';
                                        // store absolute value for later parsing by tooltips
                                        cells[colIndex[key]].setAttribute('data-original', String(n));
                                        cells[colIndex[key]].innerHTML = `<span class="${pctClass}" data-pct="${delta}">${delta.toFixed(2)}%</span>`;
                                    } else {
                                        cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                                    }
                            } else {
                                cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                            }
                        } else {
                            // If this is an RSI key, colorize via RSI thresholds; otherwise compare to CMP for color
                            if (key.startsWith('rsi_')) {
                                const v = d[dataKey] ?? d[key];
                                cells[colIndex[key]].innerHTML = (function(vv){ if (vv===null||vv===undefined||vv==='') return '<span class="cell-muted">-</span>'; const n=Number(vv); if (isNaN(n)) return '<span class="cell-muted">-</span>'; // Per user: >=70 red, <=30 green, else neutral
                                    if (n >= 70) return `<span class="rsi-neg">${n.toFixed(2)}</span>`;
                                    if (n <= 30) return `<span class="rsi-pos">${n.toFixed(2)}</span>`;
                                    return `<span class="rsi-neutral">${n.toFixed(2)}</span>`; })(v);
                            } else {
                                // EMA/DMA: color relative to CMP (neutral if equal or CMP missing)
                                const cmpAttr = cells[1]?.getAttribute && cells[1].getAttribute('data-cmp');
                                const cmpValLocal = (cmpAttr !== null && cmpAttr !== undefined) ? parseFloat(cmpAttr) : parseFloat(cells[1]?.innerText?.replace(/[^0-9.\-]/g,'') || 'NaN');
                                if (!isNaN(cmpValLocal)) {
                                    const n = parseFloat(d[dataKey] ?? d[key]);
                                    if (!isNaN(n)) {
                                        let cls = 'percent-neutral';
                                        if (cmpValLocal > n) cls = 'percent-pos';
                                        else if (cmpValLocal < n) cls = 'percent-neg';
                                        // store absolute numeric value
                                        cells[colIndex[key]].setAttribute('data-original', String(n));
                                        cells[colIndex[key]].innerHTML = `<span class="${cls}">${n.toFixed(2)}</span>`;
                                    } else {
                                        cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                                    }
                                } else {
                                    cells[colIndex[key]].innerHTML = fmt(d[dataKey]);
                                }
                            }
                        }
                    }
                }
                // No LastUpdate column in compact view
                // Update Reco cell (CMP is at col index 1)
                const cmpVal = parseFloat(cells[colIndex['CMP']]?.innerText?.replace(/[^0-9.\-]/g,'') || '');
                const readVal = (cellOrKey, idx) => {
                    // Prefer data from API (d[key]) else from cell text, stripping % if present
                    const k = cellOrKey;
                    if (d && (k in d) && d[k] !== null && d[k] !== undefined) return parseFloat(d[k]);
                    const cellText = cells[idx]?.innerText || '';
                    if (cellText.includes('%')) return parseFloat(cellText.replace('%','')) * 0.01 * cmpVal; // percent -> absolute
                    return parseFloat(cellText.replace(/[^0-9.\-]/g,''));
                };
                const ema9 = readVal('ema_9', colIndex['ema_9']);
                const ema15 = readVal('ema_15', colIndex['ema_15']);
                const ema21 = readVal('ema_21', colIndex['ema_21']);
                const dma200 = readVal('dma_200', colIndex['dma_200']);
                const rsi15 = readVal('rsi_15', colIndex['rsi_15']);
                let recoCell = row.querySelector('.reco-cell');
                if (recoCell) {
                    try {
                        // mark as pending; defer computation so all cells (EMA/DMA/RSI/CMP)
                        // stabilize first. We still attempt a near-immediate recompute
                        // shortly after to keep UI responsive when data is available.
                        recoCell.setAttribute('data-reco-state', 'pending');
                        setTimeout(() => { updateRecoForRow(symbol); }, 80);
                    } catch (e) { /* ignore */ }
                }

                        // If the payload contains a timestamp for the latest record, update the per-scanner last-update spans
                        try {
                            const ts = extractTimestampFromResult(d);
                            if (ts) {
                                ['rsi','ema','dma'].forEach(sc => {
                                    const el = document.getElementById(`last-${symbol}-${sc}`);
                                    if (el) el.innerHTML = `<span>${ts.toLocaleString()}</span>`;
                                });
                            }
                        } catch(e) { /* ignore */ }
            } catch(e) { /* ignore */ }
        }

        // Update symbol statistics
        function updateSymbolStats() {
            const total = symbols.length;
            document.getElementById('symbolStats').textContent = `${total} symbols loaded`;
        }

        // Update progress information
        function updateProgress() {
            const progressEl = document.getElementById('progressInfo');
            if (totalRunning > 0) {
                progressEl.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${totalRunning} scanners running`;
                progressEl.style.color = '#fbbf24';
            } else {
                progressEl.textContent = '';
            }
        }

        // Update status bar
        function updateStatusBar(message = 'Ready') {
            document.getElementById('statusLeft').textContent = message;
        }

        // Update current time
        function updateTime() {
            document.getElementById('currentTime').textContent = new Date().toLocaleTimeString();
        }

        // Log modal functions
        function openLogModal() {
            document.getElementById('logModal').style.display = 'block';
            loadLogs();
        }

        function closeLogModal() {
            document.getElementById('logModal').style.display = 'none';
        }

        async function loadLogs() {
            try {
                const response = await fetch('/api/logs');
                const data = await response.json();
                
                if (data.success) {
                    const logViewer = document.getElementById('logViewer');
                    if (data.logs && data.logs.length > 0) {
                        logViewer.textContent = data.logs.join('');
                        logViewer.scrollTop = logViewer.scrollHeight;
                    } else {
                        logViewer.textContent = 'No logs available';
                    }
                } else {
                    throw new Error(data.error || 'Failed to load logs');
                }
            } catch (error) {
                document.getElementById('logViewer').textContent = 'Error loading logs: ' + error.message;
                toastr.error('Failed to load logs', 'Error');
            }
        }

        async function clearLogs() {
            try {
                const response = await fetch('/api/clear-logs', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('logViewer').textContent = 'Logs cleared';
                    toastr.success('Logs cleared successfully', 'Success');
                } else {
                    throw new Error(data.error || 'Failed to clear logs');
                }
            } catch (error) {
                toastr.error('Failed to clear logs: ' + error.message, 'Error');
            }
        }

        // Click outside modal to close
        window.onclick = function(event) {
            const modal = document.getElementById('logModal');
            if (event.target === modal) {
                closeLogModal();
            }
        }

        // Dark mode
        function updateThemeToggleUI() {
            // Update any toggle icon/text for both old and new IDs
            const btn = document.getElementById('darkModeToggle') || document.getElementById('darkModeToggleTop');
            if (!btn) return;
            // Use sun icon for light mode, moon for dark
            btn.innerHTML = isDarkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            btn.setAttribute('aria-pressed', String(isDarkMode));
            console.debug('[theme] updateThemeToggleUI: isDarkMode=', isDarkMode);
        }

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.body.classList.add('dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
                document.body.classList.remove('dark');
            }
            localStorage.setItem('darkMode', JSON.stringify(isDarkMode));
            console.debug('[theme] toggleDarkMode -> isDarkMode=', isDarkMode);
            updateThemeToggleUI();
        }

        function loadDarkModePreference() {
            // Ensure isDarkMode is boolean from localStorage
            isDarkMode = JSON.parse(localStorage.getItem('darkMode') || JSON.stringify(isDarkMode));
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.body.classList.add('dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
                document.body.classList.remove('dark');
            }
            console.debug('[theme] loadDarkModePreference -> isDarkMode=', isDarkMode);
            updateThemeToggleUI();
        }

        // Chart modal for per-symbol chart
        function openChartModal(symbol) {
            // build simple modal dynamically
            const modalId = 'chartSymbolModal';
            let modal = document.getElementById(modalId);
            if (!modal) {
                modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'modal';
                modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3><i class="fas fa-chart-line"></i> Chart - <span id="chartSymbolName"></span></h3>
                        <button class="btn-close" id="closeChartModal">&times;</button>
                    </div>
                    <div style="display:flex; gap:0.75rem; align-items:center; margin-bottom:0.5rem;">
                        <label style="margin-right:6px">Scanners:</label>
                        <label style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="modalEnableEMA" checked/> EMA</label>
                        <label style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="modalEnableDMA" checked/> DMA</label>
                        <label style="margin-left:6px; display:flex; align-items:center; gap:6px;">Timeframe:</label>
                        <select id="modalTimeframeSelect" class="form-select" style="width:110px">
                            <option value="5mins">5 mins</option>
                            <option value="15mins" selected>15 mins</option>
                            <option value="30mins">30 mins</option>
                            <option value="1hour">1 hour</option>
                        </select>
                        <span style="flex:1"></span>
                        <button class="btn btn-secondary" id="reloadChartBtn"><i class="fas fa-sync"></i> Reload</button>
                    </div>
                    <!-- Two stacked canvases: price (top) and RSI (bottom) -->
                    <div style="display:flex; flex-direction:column; gap:0.5rem;">
                        <div style="height:260px;">
                            <canvas id="symbolPriceCanvas"></canvas>
                        </div>
                        <div style="height:160px;">
                            <canvas id="symbolRSICanvas"></canvas>
                        </div>
                    </div>
                </div>`;
                document.body.appendChild(modal);
                document.getElementById('closeChartModal').onclick = () => modal.style.display = 'none';
                window.addEventListener('click', (e) => { if (e.target === modal) modal.style.display='none'; });
            }
            document.getElementById('chartSymbolName').textContent = symbol;
            modal.style.display = 'block';
            const renderFromCacheOrNotify = (opts) => {
                try {
                    const tf = opts.timeframe || document.getElementById('modalTimeframeSelect')?.value || '15mins';
                    const key = `${symbol}::${tf}`;
                    const cd = chartCache[key];
                    if (cd) {
                        renderCombinedChart(cd, symbol, opts);
                    } else {
                        // Do not fetch automatically; inform user to click Reload to fetch server data
                        try { toastr.info('No cached data for selected timeframe. Click Reload to fetch from server.', 'Chart'); } catch(e){}
                    }
                } catch (e) { console.warn('renderFromCacheOrNotify failed', e); }
            };

            const loadAndCache = async () => {
                const enableEMA = document.getElementById('modalEnableEMA')?.checked ?? true;
                const enableDMA = document.getElementById('modalEnableDMA')?.checked ?? true;
                const tf = document.getElementById('modalTimeframeSelect')?.value || document.getElementById('timeframeSelect')?.value || '15mins';
                await loadSymbolChart(symbol, { enableEMA, enableDMA, timeframe: tf, forceRun: true });
            };

            // Wire checkbox toggles to re-render locally from cache (no API calls)
            const emaCb = document.getElementById('modalEnableEMA'); if (emaCb) emaCb.onchange = () => renderFromCacheOrNotify({ enableEMA: emaCb.checked, enableDMA: document.getElementById('modalEnableDMA')?.checked, timeframe: document.getElementById('modalTimeframeSelect')?.value });
            const dmaCb = document.getElementById('modalEnableDMA'); if (dmaCb) dmaCb.onchange = () => renderFromCacheOrNotify({ enableEMA: document.getElementById('modalEnableEMA')?.checked, enableDMA: dmaCb.checked, timeframe: document.getElementById('modalTimeframeSelect')?.value });
            // Reload button explicitly fetches from server
            const reload = document.getElementById('reloadChartBtn'); if (reload) reload.onclick = loadAndCache;
            // Wire timeframe dropdown to update chart from cache only (debounced)
            const tfSelect = document.getElementById('modalTimeframeSelect');
            if (tfSelect) {
                const debouncedLocalRender = debounce(() => {
                    renderFromCacheOrNotify({ enableEMA: document.getElementById('modalEnableEMA')?.checked, enableDMA: document.getElementById('modalEnableDMA')?.checked, timeframe: tfSelect.value });
                }, 250);
                tfSelect.addEventListener('change', () => {
                    try { debouncedLocalRender(); } catch(e) { console.warn('Timeframe change handler failed', e); }
                });
            }
            // Initial load: fetch and cache (user can then toggle controls without network)
            loadAndCache();
        }
    async function runScannersForSymbolTimeframe(symbol, timeframe, scanners = ['rsi','ema','dma']) {
        // Run scanners sequentially for the requested timeframe so server computes indicators at the desired granularity
        for (const scanner of scanners) {
            try {
                // Request run-single-scanner API
                showModalProgress(`Running ${scanner.toUpperCase()} for ${symbol} @ ${timeframe}...`);
                const resp = await fetch('/api/run-single-scanner', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ scanner: scanner, symbol: symbol, baseTimeframe: timeframe, daysToList: 4 })
                });
                // If network error occurs, fetch will throw and we'll jump to catch
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok || data.returncode !== 0) {
                    console.warn(`Scanner ${scanner} run for ${symbol}@${timeframe} returned:`, data);
                    try { toastr.warning(`${scanner.toUpperCase()} run returned: ${data && data.error ? data.error : 'non-zero'}`, 'Scanner'); } catch(e){}
                    // continue to next scanner; chart may still render with partial datasets
                }
                // small delay to allow CSV write/availability
                await new Promise(r => setTimeout(r, 350));
                // Inform success briefly
                showModalProgress(`${scanner.toUpperCase()} completed for ${symbol}`,'success');
            } catch (e) {
                // Network or server error; warn and continue so UI remains responsive
                console.warn('Error running scanner', scanner, e);
                try { toastr.warning(`Scanner ${scanner} run failed: ${e.message || e}`, 'Server'); } catch(err){}
                // Don't throw further; the caller will still attempt to fetch existing chart data
            }
        }
        clearModalProgress();
    }

    // Small debounce helper for UI interactions (prevents rapid repeated runs)
    function debounce(fn, wait) {
        let timer = null;
        return function(...args) {
            const ctx = this;
            if (timer) clearTimeout(timer);
            timer = setTimeout(() => { timer = null; fn.apply(ctx, args); }, wait);
        };
    }

    // Helper: fetch /api/chart-data/<scanner>/<symbol> with retries until chartData appears
    async function fetchChartDataWithRetry(scanner, symbol, maxAttempts = 8, initialDelay = 400) {
        let attempt = 0;
        let delay = initialDelay;
        while (attempt < maxAttempts) {
            try {
                showModalProgress(`Waiting for ${scanner.toUpperCase()} chart data (${attempt+1}/${maxAttempts})...`);
                const res = await fetch(`/api/chart-data/${scanner}/${symbol}`, { cache: 'no-store' });
                if (res.ok) {
                    const payload = await res.json().catch(() => ({}));
                    if (payload && payload.chartData && payload.chartData.labels && payload.chartData.datasets && payload.chartData.datasets.length > 0) {
                        clearModalProgress();
                        return payload;
                    }
                    // If response is OK but no chartData yet, wait and retry
                }
            } catch (e) {
                // Network error — server may be down; break early if connection reset
                console.warn(`fetchChartDataWithRetry network error for ${scanner}/${symbol}:`, e);
            }
            // backoff
            await new Promise(r => setTimeout(r, delay));
            attempt++;
            delay = Math.min(2000, Math.round(delay * 1.6));
        }
        // Final attempt: try once and return whatever we get (even if empty)
        try {
            const res = await fetch(`/api/chart-data/${scanner}/${symbol}`, { cache: 'no-store' });
            if (res.ok) {
                const payload = await res.json().catch(() => ({}));
                clearModalProgress();
                return payload;
            }
        } catch (e) { /* ignore */ }
        clearModalProgress();
        return null;
    }

    async function loadSymbolChart(symbol, options = { enableEMA: true, enableDMA: true, timeframe: '15mins', forceRun: false }) {
            try {
                    // If requested, trigger server to run scanners at the selected timeframe so CSVs are computed at that timeframe
                    const tf = options.timeframe || '15mins';
                    if (options.forceRun) {
                        // Run only the scanners requested/enabled to save time
                        const scannersToRun = ['rsi', 'ema', 'dma'].filter(s => (s !== 'ema' || options.enableEMA) && (s !== 'dma' || options.enableDMA));
                        await runScannersForSymbolTimeframe(symbol, tf, scannersToRun);
                    }

                    // Fetch chart data for all scanners (rsi, ema, dma) and merge into a single combined chartData
                    const scannersToFetch = ['rsi','ema','dma'];
                    // Try to fetch each scanner's chart-data with retries so we tolerate brief server processing delays
                    // First fetch OHLC resampled for the requested timeframe (preferred)
                    const q = `?timeframe=${encodeURIComponent(tf)}`;
                    let combined = { labels: null, datasets: [] };
                    const seenLabels = new Set();
                    try {
                        const ohlcRes = await fetch(`/api/chart-data/ohlc/${symbol}${q}`, { cache: 'no-store' }).catch(() => null);
                        if (ohlcRes && ohlcRes.ok) {
                            const ohlcPayload = await ohlcRes.json().catch(() => null);
                            if (ohlcPayload && ohlcPayload.chartData) {
                                const part = ohlcPayload.chartData;
                                if (Array.isArray(part.labels)) combined.labels = part.labels.slice();
                                if (Array.isArray(part.datasets)) {
                                    for (const ds of part.datasets) {
                                        const label = (ds && ds.label) ? ds.label : JSON.stringify(ds);
                                        if (seenLabels.has(label)) continue;
                                        seenLabels.add(label);
                                        const copy = Object.assign({}, ds);
                                        if (Array.isArray(ds.data)) copy.data = ds.data.slice();
                                        combined.datasets.push(copy);
                                    }
                                }
                            }
                        }
                    } catch (e) { /* ignore */ }

                    // Then fetch indicator datasets (rsi/ema/dma) to overlay on top if available
                    const fetchPromises = scannersToFetch.map(async s => {
                        try {
                            const payload = await fetchChartDataWithRetry(s, symbol, 6, 400).catch(() => null);
                            return payload;
                        } catch (e) { return null; }
                    });
                    const fetches = await Promise.all(fetchPromises);

                    for (const resp of fetches) {
                        if (!resp || resp.error || !resp.chartData) continue;
                        const part = resp.chartData;
                        if (!combined.labels && Array.isArray(part.labels)) combined.labels = part.labels.slice();
                        if (Array.isArray(part.datasets)) {
                            for (const ds of part.datasets) {
                                const label = (ds && ds.label) ? ds.label : JSON.stringify(ds);
                                if (seenLabels.has(label)) continue;
                                seenLabels.add(label);
                                const copy = Object.assign({}, ds);
                                if (Array.isArray(ds.data)) copy.data = ds.data.slice();
                                combined.datasets.push(copy);
                            }
                        }
                    }

                    if (!combined.labels || combined.datasets.length === 0) {
                        toastr.error('No chart data available for this symbol');
                        return;
                    }

                    // Filter combined datasets according to options (enableEMA / enableDMA)
                    const cd = { labels: combined.labels.slice(), datasets: [] };
                    for (const ds of combined.datasets) {
                        const lbl = (ds && ds.label) ? ds.label.toUpperCase() : '';
                        if (/^EMA\(/.test(lbl) && !options.enableEMA) continue;
                        if (/^DMA\(/.test(lbl) && !options.enableDMA) continue;
                        cd.datasets.push(ds);
                    }
                    // Cache combined chart data so modal controls can re-render locally without further API calls
                    try {
                        const cacheKey = `${symbol}::${options.timeframe || '15mins'}`;
                        chartCache[cacheKey] = cd;
                        // If a renderer helper is available, delegate rendering to it and return early
                        if (typeof renderCombinedChart === 'function') {
                            try { renderCombinedChart(cd, symbol, options); return; } catch(e) { /* fallthrough to inline render */ }
                        }
                    } catch(e) { /* ignore cache failures */ }
                    // Debugging: list merged datasets in console and show a small toast so user can verify
                    try {
                        const labelsList = cd.datasets.map(ds => ds.label || '<no-label>');
                        console.log('[chart] combined labels count=', (cd.labels && cd.labels.length) || 0, 'datasets=', labelsList);
                        if (window.toastr) toastr.info(`Combined chart built: ${labelsList.length} datasets`, 'Chart Debug');
                        // Ensure non-OHLC datasets are set to 'line' so they render when mixed with candlestick
                        for (const ds of cd.datasets) {
                            const lbl = ds && ds.label ? ds.label : '<no-label>';
                            if (!(lbl && lbl.toUpperCase() === 'OHLC')) {
                                if (!ds.type) ds.type = 'line';
                                // Coerce data values to numbers where appropriate (skip OHLC arrays)
                                if (Array.isArray(ds.data) && ds.data.length > 0 && !(typeof ds.data[0] === 'object')) {
                                    ds.data = ds.data.map(v => { const n = Number(v); return isNaN(n) ? null : n; });
                                }
                            }
                        }
                        // Detailed dump: label, type, data length and sample
                        const detailed = cd.datasets.map(ds => ({ label: ds.label || '<no-label>', type: ds.type || '<none>', len: Array.isArray(ds.data) ? ds.data.length : 'na', sample: Array.isArray(ds.data) ? ds.data.slice(0,3) : ds.data }));
                        console.log('[chart] combined detailed datasets ->', detailed);
                    } catch (e) { /* ignore */ }

                    // Destroy previous chart instances if present (use Chart.getChart to be robust)
                    try {
                        const pc = document.getElementById('symbolPriceCanvas');
                        const existingPrice = (window.Chart && pc) ? Chart.getChart(pc) : null;
                        if (existingPrice) { try { existingPrice.destroy(); } catch(e) { console.warn('Failed to destroy existing price chart', e); } }
                    } catch(e) { console.warn('Error while destroying price chart', e); }
                    try {
                        const rc = document.getElementById('symbolRSICanvas');
                        const existingRsi = (window.Chart && rc) ? Chart.getChart(rc) : null;
                        if (existingRsi) { try { existingRsi.destroy(); } catch(e) { console.warn('Failed to destroy existing rsi chart', e); } }
                    } catch(e) { console.warn('Error while destroying rsi chart', e); }

                    const textColor = isDarkMode ? '#f9fafb' : '#374151';
                    const gridColor = isDarkMode ? '#4b5563' : '#e5e7eb';

                    // Combined view: top = price (candlestick + close) + EMA/DMA overlays; bottom = RSI series if present
                    try {
                        const priceCtx = document.getElementById('symbolPriceCanvas').getContext('2d');
                        const rsiCanvasParent = document.getElementById('symbolRSICanvas').parentElement;

                        const allDatasets = cd.datasets || [];
                        const ohlc = allDatasets.find(d => d.label && d.label.toUpperCase() === 'OHLC');

                        // Detect candlestick controller availability
                        const candlestickAvailable = (typeof Chart !== 'undefined' && Chart.registry && !!Chart.registry.getController('candlestick'));

                        const priceDatasets = [];
                        if (ohlc && candlestickAvailable) {
                            const mapped = ohlc.data.map((arr, i) => ({ x: i, o: arr[0], h: arr[1], l: arr[2], c: arr[3] }));
                            priceDatasets.push({ label: 'OHLC', data: mapped, type: 'candlestick' });
                        } else if (ohlc && !candlestickAvailable) {
                            console.warn('Candlestick controller not available; falling back to close-price line');
                        }

                        // Close price dataset detection (fallback to first non-RSI numeric dataset)
                        let closeDs = allDatasets.find(d => d.label && /close/i.test(d.label));
                        if (!closeDs) closeDs = allDatasets.find(d => d.label && !/rsi|ohlc/i.test(d.label) && Array.isArray(d.data));
                        if (closeDs) {
                            priceDatasets.push({ label: closeDs.label || 'Close', data: closeDs.data, type: 'line', borderColor: 'rgb(229,237,243)', backgroundColor: 'rgba(59,130,246,0.08)', fill: false, pointRadius: 0, tension: 0.12 });
                        }

                        // Overlay EMA/DMA indicators if present
                        const indicatorSets = allDatasets.filter(d => d.label && (/EMA/i.test(d.label) || /DMA/i.test(d.label) || /ema_/i.test(d.label) || /dma_/i.test(d.label)));
                        const overlayColors = ['rgb(59,130,246)','rgb(16,185,129)','rgb(249,115,22)','rgb(14,165,233)','rgb(250,204,21)'];
                        indicatorSets.forEach((d, i) => priceDatasets.push({ label: d.label, data: d.data, type: 'line', borderColor: overlayColors[i % overlayColors.length], backgroundColor: 'rgba(0,0,0,0)', fill: false, pointRadius: 0, tension: 0.12 }));

                        // If OHLC candlesticks are present and plugin is used, convert numeric overlay datasets to {x,y}
                        // points so they align with the candlestick objects and are rendered reliably.
                        if (ohlc && candlestickAvailable) {
                            priceDatasets.forEach(ds => {
                                if (ds && ds.type === 'line' && Array.isArray(ds.data) && ds.data.length > 0 && typeof ds.data[0] !== 'object') {
                                    ds.data = ds.data.map((v, i) => ({ x: i, y: (v === null || v === undefined) ? null : Number(v) }));
                                    ds.parsing = false;
                                    ds.order = 1; // draw above candlesticks
                                    ds.borderWidth = ds.borderWidth || 2;
                                    ds.spanGaps = true;
                                }
                            });
                        } else {
                            // Ensure overlays are visible for line-only top chart
                            priceDatasets.forEach(ds => { if (ds && ds.type === 'line') { ds.order = ds.order || 1; ds.borderWidth = ds.borderWidth || 2; ds.spanGaps = true; } });
                        }

                        // Build top chart (candlestick if available; otherwise line). Force category x-axis to avoid date adapter usage.
                        const topType = (ohlc && candlestickAvailable) ? 'candlestick' : 'line';
                        const topChart = new Chart(priceCtx, {
                            type: topType,
                            data: { labels: cd.labels, datasets: priceDatasets },
                            options: {
                                responsive: true, maintainAspectRatio: false,
                                interaction: { mode: 'index', intersect: false },
                                scales: { x: { type: 'category', ticks: { color: textColor }, grid: { color: gridColor } }, y: { ticks: { color: textColor }, grid: { color: gridColor } } },
                                plugins: { legend: { labels: { color: textColor } } }
                            }
                        });
                        document.getElementById('symbolPriceCanvas')._chart = topChart;
                        document.getElementById('symbolPriceCanvas').parentElement.style.display = '';

                        // --- Synchronization helpers (hover, wheel-zoom, drag-pan) ---
                        // We synchronize by using category index indices for the x-axis (labels array indices).
                        const priceCanvas = document.getElementById('symbolPriceCanvas');
                        const rsiCanvas = document.getElementById('symbolRSICanvas');

                        // Helper: set visible window (min/max index) for both charts
                        function syncSetWindow(minIdx, maxIdx, sourceChart) {
                            // clamp
                            const maxLabelIndex = Math.max(0, cd.labels.length - 1);
                            minIdx = Math.max(0, Math.min(minIdx, maxLabelIndex));
                            maxIdx = Math.max(0, Math.min(maxIdx, maxLabelIndex));
                            if (minIdx >= maxIdx) {
                                // Ensure at least one label visible
                                if (minIdx > 0) minIdx = minIdx - 1;
                                else maxIdx = Math.min(minIdx + 1, maxLabelIndex);
                            }
                            [topChart, rsiChart].forEach(ch => {
                                if (!ch) return;
                                try {
                                    ch.options.scales.x.min = minIdx;
                                    ch.options.scales.x.max = maxIdx;
                                    // update without animation for snappy sync
                                    ch.update('none');
                                } catch (e) { /* ignore */ }
                            });
                        }

                        // Helper: get x-index under event for a chart using its x scale
                        function getIndexForEvent(chart, evt) {
                            try {
                                const xScale = chart.scales.x;
                                if (!xScale) return null;
                                // event offsetX relative to canvas
                                const rect = chart.canvas.getBoundingClientRect();
                                const clientX = evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX);
                                const px = clientX - rect.left;
                                const value = xScale.getValueForPixel(px);
                                if (value === undefined || value === null) return null;
                                // value may be fractional - round to nearest label index
                                return Math.round(Number(value));
                            } catch (e) { return null; }
                        }

                        // Hover synchronization: when hovering one chart, highlight corresponding index on the other
                        function syncHover(sourceChart, targetChart, evt) {
                            if (!sourceChart || !targetChart) return;
                            const idx = getIndexForEvent(sourceChart, evt);
                            if (idx === null || isNaN(idx)) {
                                // clear
                                try { targetChart.setActiveElements([]); targetChart.tooltip.setActiveElements([]); targetChart.update('none'); } catch(e){}
                                return;
                            }
                            // Build active elements for targetChart: include every VISIBLE dataset that has a value at this index
                            const active = [];
                            for (let di = 0; di < targetChart.data.datasets.length; di++) {
                                try {
                                    // Skip datasets that chart meta marks as hidden (e.g., legend toggled off)
                                    const meta = targetChart.getDatasetMeta ? targetChart.getDatasetMeta(di) : null;
                                    if (meta && meta.hidden) continue;
                                } catch(e) { /* ignore meta access errors */ }
                                const ds = targetChart.data.datasets[di];
                                if (!ds || !Array.isArray(ds.data)) continue;
                                // Respect dataset-level hidden flag too
                                if (ds.hidden === true) continue;
                                if (idx >= 0 && idx < ds.data.length) {
                                    const val = ds.data[idx];
                                    if (val !== null && val !== undefined) active.push({ datasetIndex: di, index: idx });
                                }
                            }
                            try {
                                targetChart.setActiveElements(active);
                                // Position tooltip slightly offset to avoid overlapping markers
                                if (active.length > 0) {
                                    // Prefer pointer coordinates (mouse/touch) and add a larger offset so tooltip
                                    // does not overlap markers. Use 20px right and 30px down by default.
                                    const clientX = evt && (evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX)) ? (evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX)) : (sourceChart.canvas.getBoundingClientRect().left + (sourceChart.width || sourceChart.canvas.width) * 0.5);
                                    const clientY = evt && (evt.clientY || (evt.touches && evt.touches[0] && evt.touches[0].clientY)) ? (evt.clientY || (evt.touches && evt.touches[0] && evt.touches[0].clientY)) : sourceChart.canvas.getBoundingClientRect().top;
                                    const x = clientX + 50;
                                    const y = clientY + 30;
                                    targetChart.tooltip.setActiveElements(active, { x: x, y: y });
                                } else {
                                    targetChart.tooltip.setActiveElements([], { x: 0, y: 0 });
                                }
                                targetChart.update('none');
                            } catch (e) {
                                // ignore errors from tooltip API if not available
                            }
                        }

                        // Attach hover events (mouse move and leave) on both canvases
                        priceCanvas.addEventListener('mousemove', function(evt) { try { syncHover(topChart, rsiChart, evt); } catch(e){} });
                        rsiCanvas.addEventListener('mousemove', function(evt) { try { syncHover(rsiChart, topChart, evt); } catch(e){} });
                        priceCanvas.addEventListener('mouseleave', function() { try { rsiChart.setActiveElements([]); rsiChart.tooltip.setActiveElements([]); rsiChart.update('none'); topChart.setActiveElements([]); topChart.tooltip.setActiveElements([]); topChart.update('none'); } catch(e){} });
                        rsiCanvas.addEventListener('mouseleave', function() { try { rsiChart.setActiveElements([]); rsiChart.tooltip.setActiveElements([]); rsiChart.update('none'); topChart.setActiveElements([]); topChart.tooltip.setActiveElements([]); topChart.update('none'); } catch(e){} });

                        // Wheel zoom: zoom centered at pointer for price canvas (and mirror to RSI)
                        (function attachWheelZoom(canvas, sourceChart) {
                            let zoomFactor = 0.15; // fraction to zoom per wheel step
                            canvas.addEventListener('wheel', function(evt) {
                                try {
                                    evt.preventDefault();
                                    const delta = Math.sign(evt.deltaY);
                                    const xScale = sourceChart.scales.x;
                                    if (!xScale) return;
                                    const curMin = (xScale.min !== undefined && xScale.min !== null) ? Number(xScale.min) : 0;
                                    const curMax = (xScale.max !== undefined && xScale.max !== null) ? Number(xScale.max) : (cd.labels.length - 1);
                                    const curRange = curMax - curMin;
                                    const centerVal = xScale.getValueForPixel(evt.offsetX);
                                    const center = (centerVal === undefined || centerVal === null) ? Math.round((curMin + curMax)/2) : Number(centerVal);
                                    // delta > 0 => zoom out, delta < 0 => zoom in
                                    const scaleDelta = (delta > 0) ? (1 + zoomFactor) : (1 - zoomFactor);
                                    let newRange = curRange * scaleDelta;
                                    // Enforce min window of 2 and max window of all labels
                                    newRange = Math.max(2, Math.min(newRange, cd.labels.length - 1));
                                    let newMin = center - newRange/2;
                                    let newMax = center + newRange/2;
                                    // clamp
                                    newMin = Math.max(0, newMin);
                                    newMax = Math.min(cd.labels.length - 1, newMax);
                                    syncSetWindow(Math.round(newMin), Math.round(newMax), sourceChart);
                                } catch (e) { console.warn('wheel zoom error', e); }
                            }, { passive: false });
                        })(priceCanvas, topChart);

                        // Drag-to-pan (mouse) on price canvas: basic implementation
                        (function attachDragPan(canvas, sourceChart) {
                            let dragging = false, startX = 0, startMin = null, startMax = null;
                            canvas.addEventListener('mousedown', function(evt) {
                                dragging = true; startX = evt.clientX; const xScale = sourceChart.scales.x; startMin = Number(xScale.min || 0); startMax = Number(xScale.max || (cd.labels.length - 1)); canvas.style.cursor = 'grabbing';
                            });
                            window.addEventListener('mouseup', function() { if (dragging) { dragging = false; canvas.style.cursor = 'default'; } });
                            window.addEventListener('mousemove', function(evt) {
                                if (!dragging) return;
                                try {
                                    const xScale = sourceChart.scales.x;
                                    const pxDelta = evt.clientX - startX;
                                    // Map pixel delta to index delta using scale
                                    const valueAtStart = xScale.getValueForPixel(startX - canvas.getBoundingClientRect().left);
                                    const valueAtShift = xScale.getValueForPixel((startX - canvas.getBoundingClientRect().left) + pxDelta);
                                    if (valueAtStart === undefined || valueAtShift === undefined) return;
                                    const idxDelta = Math.round(valueAtStart - valueAtShift);
                                    let newMin = Math.round(startMin + idxDelta);
                                    let newMax = Math.round(startMax + idxDelta);
                                    // clamp
                                    const maxLabelIndex = Math.max(0, cd.labels.length - 1);
                                    if (newMin < 0) { newMax += -newMin; newMin = 0; }
                                    if (newMax > maxLabelIndex) { newMin -= (newMax - maxLabelIndex); newMax = maxLabelIndex; }
                                    syncSetWindow(newMin, newMax, sourceChart);
                                } catch (e) { /* ignore */ }
                            });
                        })(priceCanvas, topChart);

                        // Decide on RSI panel visibility (rendered below independently)
                        const rsiSets = allDatasets.filter(ds => ds.label && /RSI/i.test(ds.label));
                        if (!rsiSets || rsiSets.length === 0) {
                            rsiCanvasParent.style.display = 'none';
                        } else {
                            rsiCanvasParent.style.display = '';
                        }
                    } catch (err) {
                        console.error('Combined price/indicator chart render failed', err);
                    }

                    // RSI CHART (bottom): render RSI series between 0-100 with threshold lines
                    try {
                        // Determine RSI thresholds from server config
                        let rsiCfg = {};
                        try {
                            const cfgRes = await fetch('/api/config/rsi');
                            if (cfgRes.ok) rsiCfg = await cfgRes.json();
                        } catch (e) { /* ignore */ }
                        const overbought = (rsiCfg && rsiCfg.rsi_overbought) ? rsiCfg.rsi_overbought : 70;
                        const oversold = (rsiCfg && rsiCfg.rsi_oversold) ? rsiCfg.rsi_oversold : 30;

                        const rsiCtx = document.getElementById('symbolRSICanvas').getContext('2d');
                        // Find RSI datasets (labels contain 'RSI')
                        const rsiSets = cd.datasets.filter(ds => ds.label && ds.label.toUpperCase().includes('RSI'));
                        const rsiDatasets = rsiSets.map((ds, i) => ({ label: ds.label, data: ds.data, borderColor: ['rgb(34,197,94)','rgb(168,85,247)','rgb(251,146,60)'][i%3], backgroundColor: 'rgba(0,0,0,0)', fill: false, pointRadius: 0, tension: 0.1 }));

                        // Add horizontal plugins for threshold lines using annotation plugin if available; otherwise draw with dataset lines
                        const plugins = [];
                        let annotationOptions = {};
                        if (window.Chart && Chart.register && Chart._adapters && Chart.register.__annotations_supported !== false) {
                            // We'll try to use the annotation plugin if present
                        }

                        // Fallback: add two thin datasets representing thresholds so lines appear
                        const thresholdDatasets = [
                            { label: 'Overbought', data: Array(cd.labels.length).fill(overbought), borderColor: 'rgba(239,68,68,0.6)', borderDash: [6,4], pointRadius: 0, fill: false, order: 0 },
                            { label: 'Oversold', data: Array(cd.labels.length).fill(oversold), borderColor: 'rgba(34,197,94,0.6)', borderDash: [6,4], pointRadius: 0, fill: false, order: 0 }
                        ];

                        const rsiChart = new Chart(rsiCtx, {
                            type: 'line',
                            data: { labels: cd.labels, datasets: [...rsiDatasets, ...thresholdDatasets] },
                            options: {
                                responsive: true, maintainAspectRatio: false,
                                scales: {
                                    x: { ticks: { color: textColor }, grid: { color: gridColor } },
                                    y: { min: 0, max: 100, ticks: { color: textColor }, grid: { color: gridColor } }
                                },
                                plugins: { legend: { labels: { color: textColor } } }
                            },
                            plugins
                        });
                        document.getElementById('symbolRSICanvas')._chart = rsiChart;
                    } catch (err) {
                        console.error('RSI chart render failed', err);
                    }
            } catch (e) { toastr.error('Failed to load chart'); }
        }

        // renderCombinedChart helper: render combined cd (labels + datasets) into the modal canvases
        // This allows modal controls (EMA/DMA/timeframe toggles) to re-render locally from cached data
        function renderCombinedChart(cd, symbol, options = { enableEMA: true, enableDMA: true, timeframe: '15mins' }) {
            try {
                if (!cd || !cd.labels || !Array.isArray(cd.labels)) throw new Error('Invalid chart data');
                const textColor = isDarkMode ? '#f9fafb' : '#374151';
                const gridColor = isDarkMode ? '#4b5563' : '#e5e7eb';

                // Build filtered datasets according to options
                const datasets = [];
                for (const ds of cd.datasets || []) {
                    const lbl = (ds && ds.label) ? ds.label.toUpperCase() : '';
                    if (/^EMA\(/.test(lbl) && !options.enableEMA) continue;
                    if (/^DMA\(/.test(lbl) && !options.enableDMA) continue;
                    datasets.push(Object.assign({}, ds));
                }

                // Destroy existing charts if present
                try { const pc = document.getElementById('symbolPriceCanvas'); const ex = (pc && window.Chart) ? Chart.getChart(pc) : null; if (ex) ex.destroy(); } catch(e) {}
                try { const rc = document.getElementById('symbolRSICanvas'); const exr = (rc && window.Chart) ? Chart.getChart(rc) : null; if (exr) exr.destroy(); } catch(e) {}

                // Prepare price/top datasets and detect OHLC
                const allDatasets = datasets;
                const ohlc = allDatasets.find(d => d.label && d.label.toUpperCase() === 'OHLC');
                const priceDatasets = [];
                const candlestickAvailable = (typeof Chart !== 'undefined' && Chart.registry && !!Chart.registry.getController('candlestick'));
                if (ohlc && candlestickAvailable) {
                    const mapped = ohlc.data.map((arr, i) => ({ x: i, o: arr[0], h: arr[1], l: arr[2], c: arr[3] }));
                    priceDatasets.push({ label: 'OHLC', data: mapped, type: 'candlestick' });
                }
                let closeDs = allDatasets.find(d => d.label && /close/i.test(d.label));
                if (!closeDs) closeDs = allDatasets.find(d => d.label && !/rsi|ohlc/i.test(d.label) && Array.isArray(d.data));
                if (closeDs) priceDatasets.push({ label: closeDs.label || 'Close', data: closeDs.data, type: 'line', borderColor: 'rgb(229,237,243)', backgroundColor: 'rgba(59,130,246,0.08)', fill: false, pointRadius: 0, tension: 0.12 });
                const indicatorSets = allDatasets.filter(d => d.label && (/EMA/i.test(d.label) || /DMA/i.test(d.label) || /ema_/i.test(d.label) || /dma_/i.test(d.label)));
                const overlayColors = ['rgb(59,130,246)','rgb(16,185,129)','rgb(249,115,22)','rgb(14,165,233)','rgb(250,204,21)'];
                indicatorSets.forEach((d,i) => priceDatasets.push({ label: d.label, data: d.data, type: 'line', borderColor: overlayColors[i%overlayColors.length], backgroundColor: 'rgba(0,0,0,0)', fill: false, pointRadius: 0, tension: 0.12 }));

                // Convert line overlays to {x,y} when OHLC present
                if (ohlc && candlestickAvailable) {
                    priceDatasets.forEach(ds => {
                        if (ds && ds.type === 'line' && Array.isArray(ds.data) && ds.data.length > 0 && typeof ds.data[0] !== 'object') {
                            ds.data = ds.data.map((v,i) => ({ x: i, y: (v===null||v===undefined)?null:Number(v) }));
                            ds.parsing = false; ds.order = 1; ds.borderWidth = ds.borderWidth || 2; ds.spanGaps = true;
                        }
                    });
                } else {
                    priceDatasets.forEach(ds => { if (ds && ds.type === 'line') { ds.order = ds.order || 1; ds.borderWidth = ds.borderWidth || 2; ds.spanGaps = true; } });
                }

                // Build top chart (price)
                try {
                    const priceCtx = document.getElementById('symbolPriceCanvas').getContext('2d');
                    const topType = (ohlc && candlestickAvailable) ? 'candlestick' : 'line';
                    const topChart = new Chart(priceCtx, {
                        type: topType,
                        data: { labels: cd.labels, datasets: priceDatasets },
                        options: { responsive:true, maintainAspectRatio:false, interaction:{mode:'index',intersect:false}, scales:{ x:{ type:'category', ticks:{ color:textColor }, grid:{ color:gridColor } }, y:{ ticks:{ color:textColor }, grid:{ color:gridColor } } }, plugins:{ legend:{ labels:{ color:textColor } } } }
                    });
                    document.getElementById('symbolPriceCanvas')._chart = topChart;
                } catch(e) { console.warn('Failed to render top chart', e); }

                // RSI chart (bottom)
                const rsiSets = datasets.filter(ds => ds.label && /RSI/i.test(ds.label));
                const rsiCanvasParent = document.getElementById('symbolRSICanvas').parentElement;
                if (!rsiSets || rsiSets.length === 0) {
                    rsiCanvasParent.style.display = 'none';
                } else {
                    rsiCanvasParent.style.display = '';
                    try {
                        const rsiCtx = document.getElementById('symbolRSICanvas').getContext('2d');
                        const rsiDatasets = rsiSets.map((ds,i) => ({ label: ds.label, data: ds.data, borderColor: ['rgb(34,197,94)','rgb(168,85,247)','rgb(251,146,60)'][i%3], backgroundColor:'rgba(0,0,0,0)', fill:false, pointRadius:0, tension:0.1 }));
                        const overbought = 70, oversold = 30;
                        const thresholdDatasets = [ { label:'Overbought', data: Array(cd.labels.length).fill(overbought), borderColor:'rgba(239,68,68,0.6)', borderDash:[6,4], pointRadius:0, fill:false, order:0 }, { label:'Oversold', data: Array(cd.labels.length).fill(oversold), borderColor:'rgba(34,197,94,0.6)', borderDash:[6,4], pointRadius:0, fill:false, order:0 } ];
                        const rsiChart = new Chart(rsiCtx, { type:'line', data:{ labels: cd.labels, datasets: [...rsiDatasets, ...thresholdDatasets] }, options:{ responsive:true, maintainAspectRatio:false, scales:{ x:{ ticks:{ color:textColor }, grid:{ color:gridColor } }, y:{ min:0, max:100, ticks:{ color:textColor }, grid:{ color:gridColor } } }, plugins:{ legend:{ labels:{ color:textColor } } } } });
                        document.getElementById('symbolRSICanvas')._chart = rsiChart;
                    } catch(e) { console.warn('Failed to render RSI chart', e); }
                }

                // Simple hover sync between price and RSI charts
                try {
                    const priceCanvas = document.getElementById('symbolPriceCanvas');
                    const rsiCanvas = document.getElementById('symbolRSICanvas');
                    const topChart = Chart.getChart(priceCanvas);
                    const rsiChart = Chart.getChart(rsiCanvas);
                    function getIndexForEvent(chart, evt) { try { const xScale = chart.scales.x; if (!xScale) return null; const rect = chart.canvas.getBoundingClientRect(); const px = (evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX)) - rect.left; const val = xScale.getValueForPixel(px); return (val===undefined||val===null)?null:Math.round(Number(val)); } catch(e){return null;} }
                    function syncHover(sourceChart, targetChart, evt) {
                        try {
                            const idx = getIndexForEvent(sourceChart, evt);
                            if (idx === null) {
                                try { if (targetChart) { targetChart.setActiveElements([]); targetChart.tooltip.setActiveElements([]); targetChart.update('none'); } } catch(e){}
                                return;
                            }
                            const active = [];
                            for (let di = 0; di < targetChart.data.datasets.length; di++) {
                                try {
                                    const meta = targetChart.getDatasetMeta ? targetChart.getDatasetMeta(di) : null;
                                    if (meta && meta.hidden) continue;
                                } catch(e) {}
                                const ds = targetChart.data.datasets[di];
                                if (!ds || !Array.isArray(ds.data)) continue;
                                if (ds.hidden === true) continue;
                                if (idx >= 0 && idx < ds.data.length) {
                                    const val = ds.data[idx];
                                    if (val !== null && val !== undefined) active.push({ datasetIndex: di, index: idx });
                                }
                            }
                            try {
                                if (targetChart) {
                                    targetChart.setActiveElements(active);
                                    if (active.length > 0) {
                                        const clientX = evt && (evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX)) ? (evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX)) : (sourceChart.canvas.getBoundingClientRect().left + (sourceChart.width || sourceChart.canvas.width) * 0.5);
                                        const clientY = evt && (evt.clientY || (evt.touches && evt.touches[0] && evt.touches[0].clientY)) ? (evt.clientY || (evt.touches && evt.touches[0] && evt.touches[0].clientY)) : sourceChart.canvas.getBoundingClientRect().top;
                                        const x = clientX + 50;
                                        const y = clientY + 30;
                                        targetChart.tooltip.setActiveElements(active, { x: x, y: y });
                                    } else {
                                        targetChart.tooltip.setActiveElements([], { x: 0, y: 0 });
                                    }
                                    targetChart.update('none');
                                }
                            } catch(e) {}
                        } catch(e) {}
                    }
                    priceCanvas.addEventListener('mousemove', function(evt) { try { syncHover(topChart, rsiChart, evt); } catch(e){} });
                    rsiCanvas.addEventListener('mousemove', function(evt) { try { syncHover(rsiChart, topChart, evt); } catch(e){} });
                    priceCanvas.addEventListener('mouseleave', function() { try { if (rsiChart) { rsiChart.setActiveElements([]); rsiChart.tooltip.setActiveElements([]); rsiChart.update('none'); } if (topChart) { topChart.setActiveElements([]); topChart.tooltip.setActiveElements([]); topChart.update('none'); } } catch(e){} });
                } catch(e) { /* ignore sync errors */ }
                // --- Crosshair overlay: draw vertical/horizontal cross marker synchronized between charts ---
                try {
                    const createOverlay = (baseCanvas, id) => {
                        let overlay = document.getElementById(id);
                        const parent = baseCanvas.parentElement;
                        if (!parent) return null;
                        parent.style.position = parent.style.position || 'relative';
                        if (!overlay) {
                            overlay = document.createElement('canvas');
                            overlay.id = id;
                            overlay.style.position = 'absolute';
                            overlay.style.left = '0'; overlay.style.top = '0';
                            overlay.style.width = '100%'; overlay.style.height = '100%';
                            overlay.style.pointerEvents = 'none';
                            overlay.style.zIndex = 1001;
                            parent.appendChild(overlay);
                        }
                        const resize = () => {
                            const rect = baseCanvas.getBoundingClientRect();
                            const dpr = window.devicePixelRatio || 1;
                            overlay.width = Math.round(rect.width * dpr);
                            overlay.height = Math.round(rect.height * dpr);
                            overlay.style.width = rect.width + 'px';
                            overlay.style.height = rect.height + 'px';
                            const ctx = overlay.getContext('2d'); if (ctx) ctx.setTransform(dpr,0,0,dpr,0,0);
                        };
                        // initial resize
                        resize();
                        // keep in sync on window resize
                        window.addEventListener('resize', resize);
                        return { overlay, resize };
                    };

                    const priceOverlayObj = createOverlay(document.getElementById('symbolPriceCanvas'), 'symbolPriceOverlay');
                    const rsiOverlayObj = createOverlay(document.getElementById('symbolRSICanvas'), 'symbolRsiOverlay');

                    const drawCross = (overlay, x, y) => {
                        if (!overlay) return;
                        const ctx = overlay.getContext('2d');
                        if (!ctx) return;
                        const rect = overlay.getBoundingClientRect();
                        ctx.clearRect(0,0,rect.width,rect.height);
                        ctx.save();
                        ctx.strokeStyle = 'rgba(120,120,120,0.9)';
                        ctx.lineWidth = 1;
                        // vertical
                        ctx.beginPath(); ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, rect.height); ctx.stroke();
                        // horizontal
                        ctx.beginPath(); ctx.moveTo(0, y + 0.5); ctx.lineTo(rect.width, y + 0.5); ctx.stroke();
                        // circle at intersection
                        ctx.fillStyle = 'rgba(80,80,80,0.9)'; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    };

                    const clearOverlay = (overlay) => { if (!overlay) return; const ctx = overlay.getContext('2d'); if (!ctx) return; const rect = overlay.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); };

                    const priceCanvasEl = document.getElementById('symbolPriceCanvas');
                    const rsiCanvasEl = document.getElementById('symbolRSICanvas');
                    if (priceCanvasEl) {
                        priceCanvasEl.addEventListener('mousemove', function(evt) {
                            try {
                                const prect = priceCanvasEl.getBoundingClientRect();
                                const rx = evt.clientX - prect.left;
                                const ry = evt.clientY - prect.top;
                                if (priceOverlayObj && priceOverlayObj.overlay) drawCross(priceOverlayObj.overlay, rx, ry);
                                // mirror vertical line to RSI overlay using relative X proportion
                                if (rsiOverlayObj && rsiOverlayObj.overlay) {
                                    const rrect = rsiCanvasEl.getBoundingClientRect();
                                    const ratio = (rx / prect.width) || 0;
                                    const rxPos = Math.round(rrect.width * ratio);
                                    // place horizontal in middle of RSI overlay
                                    const ryMid = Math.round(rrect.height * 0.5);
                                    drawCross(rsiOverlayObj.overlay, rxPos, ryMid);
                                }
                            } catch(e) {}
                        });
                        priceCanvasEl.addEventListener('mouseleave', function() { try { if (priceOverlayObj) clearOverlay(priceOverlayObj.overlay); if (rsiOverlayObj) clearOverlay(rsiOverlayObj.overlay); } catch(e){} });
                    }
                } catch(e) { console.warn('crosshair overlay setup failed', e); }
            } catch (e) { console.error('renderCombinedChart error', e); }
        }
    </script>
</body>
</html>
